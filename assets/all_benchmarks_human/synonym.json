[
    {
        "SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Bad'",
        "tables": [
            "superhero",
            "alignment"
        ],
        "columns": [
            "superhero.superhero_name",
            "alignment.alignment",
            "superhero.alignment_id",
            "alignment.id"
        ],
        "values": [
            {
                "table": "alignment",
                "column": "alignment",
                "value": "Bad",
                "condition": "="
            }
        ],
        "db_id": "superhero",
        "source": "bird_dev",
        "evidence": "names of superheroes refers to superhero_name; neutral alignment refers to alignment = 'Neutral';",
        "values_list": [
            "alignment.alignment.bad"
        ],
        "original_question": "Describe the names of neutral alignment superheroes.",
        "question": "Describe the names of evil alignment superheroes.",
        "original_SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'",
        "changes_information": {
            "original_value": "Bad",
            "synonym": "evil"
        }
    },
    {
        "SQL": "SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_attribute AS T2 INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Strength' AND T2.attribute_value < 50 AND T1.id = T2.hero_id)",
        "tables": [
            "hero_attribute",
            "superhero",
            "attribute"
        ],
        "columns": [
            "hero_attribute.attribute_value",
            "superhero.id",
            "attribute.id",
            "hero_attribute.hero_id",
            "attribute.attribute_name",
            "hero_attribute.attribute_id"
        ],
        "values": [
            {
                "table": "attribute",
                "column": "attribute_name",
                "value": "Strength",
                "condition": "="
            },
            {
                "table": "hero_attribute",
                "column": "attribute_value",
                "value": "50",
                "condition": "<"
            }
        ],
        "db_id": "superhero",
        "source": "bird_dev",
        "evidence": "durability of less than 50 refers to attribute_name = 'Durability' AND attribute_value < 50",
        "values_list": [
            "attribute.attribute_name.strength",
            "hero_attribute.attribute_value.50"
        ],
        "original_question": "Which superheroes have a durability attribute value of less than 50?",
        "question": "Which superheroes have a power attribute value of less than 50?",
        "original_SQL": "SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_attribute AS T2 INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Durability' AND T2.attribute_value < 50 AND T1.id = T2.hero_id)",
        "changes_information": {
            "original_value": "Strength",
            "synonym": "power"
        }
    },
    {
        "SQL": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Strength' ORDER BY T2.attribute_value DESC LIMIT 1",
        "tables": [
            "hero_attribute",
            "superhero",
            "attribute"
        ],
        "columns": [
            "hero_attribute.attribute_value",
            "superhero.id",
            "superhero.full_name",
            "attribute.id",
            "hero_attribute.hero_id",
            "attribute.attribute_name",
            "hero_attribute.attribute_id"
        ],
        "values": [
            {
                "table": "attribute",
                "column": "attribute_name",
                "value": "Strength",
                "condition": "="
            }
        ],
        "db_id": "superhero",
        "source": "bird_dev",
        "evidence": "highest attribute in strength refers to MAX(attribute_value) WHERE attribute_name = 'strength';",
        "values_list": [
            "attribute.attribute_name.strength"
        ],
        "original_question": "What is the hero's full name with the highest attribute in strength?",
        "question": "What is the hero's full name with the highest attribute in power?",
        "original_SQL": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Strength' ORDER BY T2.attribute_value DESC LIMIT 1",
        "changes_information": {
            "original_value": "Strength",
            "synonym": "power"
        }
    },
    {
        "SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T3.id = T2.attribute_id INNER JOIN publisher AS T4 ON T4.id = T1.publisher_id WHERE T4.publisher_name = 'Dark Horse Comics' AND T3.attribute_name = 'Strength' ORDER BY T2.attribute_value DESC LIMIT 1",
        "tables": [
            "publisher",
            "hero_attribute",
            "superhero",
            "attribute"
        ],
        "columns": [
            "superhero.id",
            "superhero.superhero_name",
            "publisher.publisher_name",
            "attribute.attribute_name",
            "publisher.id",
            "attribute.id",
            "hero_attribute.hero_id",
            "hero_attribute.attribute_value",
            "superhero.publisher_id",
            "hero_attribute.attribute_id"
        ],
        "values": [
            {
                "table": "publisher",
                "column": "publisher_name",
                "value": "Dark Horse Comics",
                "condition": "="
            },
            {
                "table": "attribute",
                "column": "attribute_name",
                "value": "Strength",
                "condition": "="
            }
        ],
        "db_id": "superhero",
        "source": "bird_dev",
        "evidence": "which superhero refers to superhero_name; most durability refers to MAX(attribute_value) WHERE attribute_name = 'durability'; published by Dark Horse Comics refers to publisher_name = 'Dark Horse Comics';",
        "values_list": [
            "publisher.publisher_name.dark horse comics",
            "attribute.attribute_name.strength"
        ],
        "original_question": "Which superhero has the most durability published by Dark Horse Comics?",
        "question": "Which superhero has the most power published by Dark Horse Comics?",
        "original_SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T3.id = T2.attribute_id INNER JOIN publisher AS T4 ON T4.id = T1.publisher_id WHERE T4.publisher_name = 'Dark Horse Comics' AND T3.attribute_name = 'Durability' ORDER BY T2.attribute_value DESC LIMIT 1",
        "changes_information": {
            "original_value": "Strength",
            "synonym": "power"
        }
    },
    {
        "SQL": "SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_attribute AS T2 INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Speed' AND T2.attribute_value < 50 AND T1.id = T2.hero_id)",
        "tables": [
            "hero_attribute",
            "superhero",
            "attribute"
        ],
        "columns": [
            "hero_attribute.attribute_value",
            "superhero.id",
            "attribute.id",
            "hero_attribute.hero_id",
            "attribute.attribute_name",
            "hero_attribute.attribute_id"
        ],
        "values": [
            {
                "table": "attribute",
                "column": "attribute_name",
                "value": "Speed",
                "condition": "="
            },
            {
                "table": "hero_attribute",
                "column": "attribute_value",
                "value": "50",
                "condition": "<"
            }
        ],
        "db_id": "superhero",
        "source": "bird_dev",
        "evidence": "durability of less than 50 refers to attribute_name = 'Durability' AND attribute_value < 50",
        "values_list": [
            "attribute.attribute_name.speed",
            "hero_attribute.attribute_value.50"
        ],
        "original_question": "Which superheroes have a durability attribute value of less than 50?",
        "question": "Which superheroes have a Velocity attribute value of less than 50?",
        "original_SQL": "SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_attribute AS T2 INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Durability' AND T2.attribute_value < 50 AND T1.id = T2.hero_id)",
        "changes_information": {
            "original_value": "Speed",
            "synonym": "Velocity"
        }
    },
    {
        "SQL": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Speed' ORDER BY T2.attribute_value DESC LIMIT 1",
        "tables": [
            "hero_attribute",
            "superhero",
            "attribute"
        ],
        "columns": [
            "hero_attribute.attribute_value",
            "superhero.id",
            "superhero.full_name",
            "attribute.id",
            "hero_attribute.hero_id",
            "attribute.attribute_name",
            "hero_attribute.attribute_id"
        ],
        "values": [
            {
                "table": "attribute",
                "column": "attribute_name",
                "value": "Speed",
                "condition": "="
            }
        ],
        "db_id": "superhero",
        "source": "bird_dev",
        "evidence": "highest attribute in strength refers to MAX(attribute_value) WHERE attribute_name = 'strength';",
        "values_list": [
            "attribute.attribute_name.speed"
        ],
        "original_question": "What is the hero's full name with the highest attribute in strength?",
        "question": "What is the hero's full name with the highest attribute in Velocity?",
        "original_SQL": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Strength' ORDER BY T2.attribute_value DESC LIMIT 1",
        "changes_information": {
            "original_value": "Speed",
            "synonym": "Velocity"
        }
    },
    {
        "SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T3.id = T2.attribute_id INNER JOIN publisher AS T4 ON T4.id = T1.publisher_id WHERE T4.publisher_name = 'Dark Horse Comics' AND T3.attribute_name = 'Speed' ORDER BY T2.attribute_value DESC LIMIT 1",
        "tables": [
            "publisher",
            "hero_attribute",
            "superhero",
            "attribute"
        ],
        "columns": [
            "superhero.id",
            "superhero.superhero_name",
            "publisher.publisher_name",
            "attribute.attribute_name",
            "publisher.id",
            "attribute.id",
            "hero_attribute.hero_id",
            "hero_attribute.attribute_value",
            "superhero.publisher_id",
            "hero_attribute.attribute_id"
        ],
        "values": [
            {
                "table": "publisher",
                "column": "publisher_name",
                "value": "Dark Horse Comics",
                "condition": "="
            },
            {
                "table": "attribute",
                "column": "attribute_name",
                "value": "Speed",
                "condition": "="
            }
        ],
        "db_id": "superhero",
        "source": "bird_dev",
        "evidence": "which superhero refers to superhero_name; most durability refers to MAX(attribute_value) WHERE attribute_name = 'durability'; published by Dark Horse Comics refers to publisher_name = 'Dark Horse Comics';",
        "values_list": [
            "publisher.publisher_name.dark horse comics",
            "attribute.attribute_name.speed"
        ],
        "original_question": "Which superhero has the most durability published by Dark Horse Comics?",
        "question": "Which superhero has the most Velocity published by Dark Horse Comics?",
        "original_SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T3.id = T2.attribute_id INNER JOIN publisher AS T4 ON T4.id = T1.publisher_id WHERE T4.publisher_name = 'Dark Horse Comics' AND T3.attribute_name = 'Durability' ORDER BY T2.attribute_value DESC LIMIT 1",
        "changes_information": {
            "original_value": "Speed",
            "synonym": "Velocity"
        }
    },
    {
        "SQL": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Teacher' LIMIT 10",
        "tables": [
            "badges",
            "users"
        ],
        "columns": [
            "users.id",
            "badges.userid",
            "users.displayname",
            "badges.name"
        ],
        "values": [
            {
                "table": "badges",
                "column": "name",
                "value": "Teacher",
                "condition": "="
            }
        ],
        "db_id": "codebase_community",
        "source": "bird_dev",
        "evidence": "\"Necromancer\" is the Name of badge; users refers to DisplayName",
        "values_list": [
            "badges.name.teacher"
        ],
        "original_question": "Name 10 users with the badge name 'Necromancer.'",
        "question": "Name 10 users with the badge name 'Instructor.'",
        "original_SQL": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Necromancer' LIMIT 10",
        "changes_information": {
            "original_value": "Teacher",
            "synonym": "Instructor"
        }
    },
    {
        "SQL": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.`Name` = 'Teacher'",
        "tables": [
            "badges",
            "users"
        ],
        "columns": [
            "users.id",
            "badges.userid",
            "users.displayname",
            "badges.name"
        ],
        "values": [
            {
                "table": "badges",
                "column": "name",
                "value": "Teacher",
                "condition": "="
            }
        ],
        "db_id": "codebase_community",
        "source": "bird_dev",
        "evidence": "name of users refers to DisplayName; the Organizer Badges refer to badges where Name = 'Organizer';",
        "values_list": [
            "badges.name.teacher"
        ],
        "original_question": "List all the name of users that obtained the Organizer Badges.",
        "question": "List all the name of users that obtained the Instructor Badges.",
        "original_SQL": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.`Name` = 'Organizer'",
        "changes_information": {
            "original_value": "Teacher",
            "synonym": "Instructor"
        }
    },
    {
        "SQL": "SELECT T1.LastAccessDate, T1.Location FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Teacher'",
        "tables": [
            "badges",
            "users"
        ],
        "columns": [
            "users.location",
            "badges.userid",
            "badges.name",
            "users.id",
            "users.lastaccessdate"
        ],
        "values": [
            {
                "table": "badges",
                "column": "name",
                "value": "Teacher",
                "condition": "="
            }
        ],
        "db_id": "codebase_community",
        "source": "bird_dev",
        "evidence": "Outliers is the name of the badge;",
        "values_list": [
            "badges.name.teacher"
        ],
        "original_question": "Describe the last accessed date and location of the users who received the outliers badge.",
        "question": "Describe the last accessed date and location of the users who received the Instructor badge.",
        "original_SQL": "SELECT T1.LastAccessDate, T1.Location FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'outliers'",
        "changes_information": {
            "original_value": "Teacher",
            "synonym": "Instructor"
        }
    },
    {
        "SQL": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.`Name` = 'Teacher' ORDER BY T2.Date LIMIT 1",
        "tables": [
            "badges",
            "users"
        ],
        "columns": [
            "badges.userid",
            "badges.name",
            "users.id",
            "users.displayname",
            "badges.date"
        ],
        "values": [
            {
                "table": "badges",
                "column": "name",
                "value": "Teacher",
                "condition": "="
            }
        ],
        "db_id": "codebase_community",
        "source": "bird_dev",
        "evidence": "Autobiographer is the name of the badge; acquired the first refers to MIN(Date);",
        "values_list": [
            "badges.name.teacher"
        ],
        "original_question": "What is the display name of the user who acquired the first Autobiographer badge?",
        "question": "What is the display name of the user who acquired the first Instructor badge?",
        "original_SQL": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.`Name` = 'Autobiographer' ORDER BY T2.Date LIMIT 1",
        "changes_information": {
            "original_value": "Teacher",
            "synonym": "Instructor"
        }
    },
    {
        "SQL": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Student' LIMIT 10",
        "tables": [
            "badges",
            "users"
        ],
        "columns": [
            "users.id",
            "badges.userid",
            "users.displayname",
            "badges.name"
        ],
        "values": [
            {
                "table": "badges",
                "column": "name",
                "value": "Student",
                "condition": "="
            }
        ],
        "db_id": "codebase_community",
        "source": "bird_dev",
        "evidence": "\"Necromancer\" is the Name of badge; users refers to DisplayName",
        "values_list": [
            "badges.name.student"
        ],
        "original_question": "Name 10 users with the badge name 'Necromancer.'",
        "question": "Name 10 users with the badge name 'Learner.'",
        "original_SQL": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Necromancer' LIMIT 10",
        "changes_information": {
            "original_value": "Student",
            "synonym": "Learner"
        }
    },
    {
        "SQL": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.`Name` = 'Student'",
        "tables": [
            "badges",
            "users"
        ],
        "columns": [
            "users.id",
            "badges.userid",
            "users.displayname",
            "badges.name"
        ],
        "values": [
            {
                "table": "badges",
                "column": "name",
                "value": "Student",
                "condition": "="
            }
        ],
        "db_id": "codebase_community",
        "source": "bird_dev",
        "evidence": "name of users refers to DisplayName; the Organizer Badges refer to badges where Name = 'Organizer';",
        "values_list": [
            "badges.name.student"
        ],
        "original_question": "List all the name of users that obtained the Organizer Badges.",
        "question": "List all the name of users that obtained the Learner Badges.",
        "original_SQL": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.`Name` = 'Organizer'",
        "changes_information": {
            "original_value": "Student",
            "synonym": "Learner"
        }
    },
    {
        "SQL": "SELECT T1.LastAccessDate, T1.Location FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Student'",
        "tables": [
            "badges",
            "users"
        ],
        "columns": [
            "users.location",
            "badges.userid",
            "badges.name",
            "users.id",
            "users.lastaccessdate"
        ],
        "values": [
            {
                "table": "badges",
                "column": "name",
                "value": "Student",
                "condition": "="
            }
        ],
        "db_id": "codebase_community",
        "source": "bird_dev",
        "evidence": "Outliers is the name of the badge;",
        "values_list": [
            "badges.name.student"
        ],
        "original_question": "Describe the last accessed date and location of the users who received the outliers badge.",
        "question": "Describe the last accessed date and location of the users who received the Learner badge.",
        "original_SQL": "SELECT T1.LastAccessDate, T1.Location FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'outliers'",
        "changes_information": {
            "original_value": "Student",
            "synonym": "Learner"
        }
    },
    {
        "SQL": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.`Name` = 'Student' ORDER BY T2.Date LIMIT 1",
        "tables": [
            "badges",
            "users"
        ],
        "columns": [
            "badges.userid",
            "badges.name",
            "users.id",
            "users.displayname",
            "badges.date"
        ],
        "values": [
            {
                "table": "badges",
                "column": "name",
                "value": "Student",
                "condition": "="
            }
        ],
        "db_id": "codebase_community",
        "source": "bird_dev",
        "evidence": "Autobiographer is the name of the badge; acquired the first refers to MIN(Date);",
        "values_list": [
            "badges.name.student"
        ],
        "original_question": "What is the display name of the user who acquired the first Autobiographer badge?",
        "question": "What is the display name of the user who acquired the first Learner badge?",
        "original_SQL": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.`Name` = 'Autobiographer' ORDER BY T2.Date LIMIT 1",
        "changes_information": {
            "original_value": "Student",
            "synonym": "Learner"
        }
    },
    {
        "SQL": "SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Rocks' EXCEPT SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Scissors'",
        "tables": [
            "warehouses",
            "boxes"
        ],
        "columns": [
            "boxes.warehouse",
            "warehouses.code",
            "warehouses.location",
            "boxes.contents"
        ],
        "values": [
            {
                "table": "boxes",
                "column": "contents",
                "value": "Rocks",
                "condition": "="
            },
            {
                "table": "boxes",
                "column": "contents",
                "value": "Scissors",
                "condition": "="
            }
        ],
        "db_id": "warehouse_1",
        "source": "spider_test",
        "evidence": "",
        "values_list": [
            "boxes.contents.rocks",
            "boxes.contents.scissors"
        ],
        "original_question": "Find the location of the warehouses which have contents Rocks but not Scissors.",
        "question": "Find the location of the warehouses which have contents stones but not Scissors.",
        "original_SQL": "SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Rocks' EXCEPT SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Scissors'",
        "changes_information": {
            "original_value": "Rocks",
            "synonym": "stones"
        }
    },
    {
        "SQL": "SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Rocks' EXCEPT SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Scissors'",
        "tables": [
            "warehouses",
            "boxes"
        ],
        "columns": [
            "boxes.warehouse",
            "warehouses.code",
            "warehouses.location",
            "boxes.contents"
        ],
        "values": [
            {
                "table": "boxes",
                "column": "contents",
                "value": "Rocks",
                "condition": "="
            },
            {
                "table": "boxes",
                "column": "contents",
                "value": "Scissors",
                "condition": "="
            }
        ],
        "db_id": "warehouse_1",
        "source": "spider_test",
        "evidence": "",
        "values_list": [
            "boxes.contents.rocks",
            "boxes.contents.scissors"
        ],
        "original_question": "What are the locations of warehouses that have boxes containing Rocks but not Scissors?",
        "question": "What are the locations of warehouses that have boxes containing stones but not Scissors?",
        "original_SQL": "SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Rocks' EXCEPT SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Scissors'",
        "changes_information": {
            "original_value": "Rocks",
            "synonym": "stones"
        }
    },
    {
        "SQL": "SELECT DISTINCT warehouse FROM boxes WHERE CONTENTS  =  'Rocks' OR CONTENTS  =  'Rocks'",
        "tables": [
            "boxes"
        ],
        "columns": [
            "boxes.warehouse",
            "boxes.contents"
        ],
        "values": [
            {
                "table": "boxes",
                "column": "contents",
                "value": "Rocks",
                "condition": "="
            },
            {
                "table": "boxes",
                "column": "contents",
                "value": "Rocks",
                "condition": "="
            }
        ],
        "db_id": "warehouse_1",
        "source": "spider_test",
        "evidence": "",
        "values_list": [
            "boxes.contents.rocks",
            "boxes.contents.rocks"
        ],
        "original_question": "Find the warehouses which store contents Rocks or Scissors.",
        "question": "Find the warehouses which store contents Rocks or stones.",
        "original_SQL": "SELECT DISTINCT warehouse FROM boxes WHERE CONTENTS  =  'Rocks' OR CONTENTS  =  'Scissors'",
        "changes_information": {
            "original_value": "Rocks",
            "synonym": "stones"
        }
    },
    {
        "SQL": "SELECT DISTINCT warehouse FROM boxes WHERE CONTENTS  =  'Rocks' OR CONTENTS  =  'Rocks'",
        "tables": [
            "boxes"
        ],
        "columns": [
            "boxes.warehouse",
            "boxes.contents"
        ],
        "values": [
            {
                "table": "boxes",
                "column": "contents",
                "value": "Rocks",
                "condition": "="
            },
            {
                "table": "boxes",
                "column": "contents",
                "value": "Rocks",
                "condition": "="
            }
        ],
        "db_id": "warehouse_1",
        "source": "spider_test",
        "evidence": "",
        "values_list": [
            "boxes.contents.rocks",
            "boxes.contents.rocks"
        ],
        "original_question": "What are the distinct warehouses that have boxes with Rocks or Scissors as contents?",
        "question": "What are the distinct warehouses that have boxes with Rocks or stones as contents?",
        "original_SQL": "SELECT DISTINCT warehouse FROM boxes WHERE CONTENTS  =  'Rocks' OR CONTENTS  =  'Scissors'",
        "changes_information": {
            "original_value": "Rocks",
            "synonym": "stones"
        }
    },
    {
        "SQL": "SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Rocks' INTERSECT SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Scissors'",
        "tables": [
            "warehouses",
            "boxes"
        ],
        "columns": [
            "boxes.warehouse",
            "warehouses.code",
            "warehouses.location",
            "boxes.contents"
        ],
        "values": [
            {
                "table": "boxes",
                "column": "contents",
                "value": "Rocks",
                "condition": "="
            },
            {
                "table": "boxes",
                "column": "contents",
                "value": "Scissors",
                "condition": "="
            }
        ],
        "db_id": "warehouse_1",
        "source": "spider_test",
        "evidence": "",
        "values_list": [
            "boxes.contents.rocks",
            "boxes.contents.scissors"
        ],
        "original_question": "Find the location of the warehouses which store contents Rocks and Scissors.",
        "question": "Find the location of the warehouses which store contents stones and Scissors.",
        "original_SQL": "SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Rocks' INTERSECT SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Scissors'",
        "changes_information": {
            "original_value": "Rocks",
            "synonym": "stones"
        }
    },
    {
        "SQL": "SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Rocks' INTERSECT SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Scissors'",
        "tables": [
            "warehouses",
            "boxes"
        ],
        "columns": [
            "boxes.warehouse",
            "warehouses.code",
            "warehouses.location",
            "boxes.contents"
        ],
        "values": [
            {
                "table": "boxes",
                "column": "contents",
                "value": "Rocks",
                "condition": "="
            },
            {
                "table": "boxes",
                "column": "contents",
                "value": "Scissors",
                "condition": "="
            }
        ],
        "db_id": "warehouse_1",
        "source": "spider_test",
        "evidence": "",
        "values_list": [
            "boxes.contents.rocks",
            "boxes.contents.scissors"
        ],
        "original_question": "What are the locations of warehouses in which boxes that contain Rocks and Scissors are kept?",
        "question": "What are the locations of warehouses in which boxes that contain stones and Scissors are kept?",
        "original_SQL": "SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Rocks' INTERSECT SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Scissors'",
        "changes_information": {
            "original_value": "Rocks",
            "synonym": "stones"
        }
    },
    {
        "SQL": "SELECT code FROM boxes WHERE value  >  (SELECT min(value) FROM boxes WHERE CONTENTS  =  'Rocks')",
        "tables": [
            "boxes"
        ],
        "columns": [
            "boxes.contents",
            "boxes.value",
            "boxes.code"
        ],
        "values": [
            {
                "table": "boxes",
                "column": "contents",
                "value": "Rocks",
                "condition": "="
            },
            {
                "table": "",
                "column": "contents",
                "value": "Rocks",
                "condition": "="
            }
        ],
        "db_id": "warehouse_1",
        "source": "spider_test",
        "evidence": "",
        "values_list": [
            "boxes.contents.rocks",
            ".contents.rocks"
        ],
        "original_question": "Find the code of all boxes whose value is higher than the value of any boxes with Rocks as content.",
        "question": "Find the code of all boxes whose value is higher than the value of any boxes with stones as content.",
        "original_SQL": "SELECT code FROM boxes WHERE value  >  (SELECT min(value) FROM boxes WHERE CONTENTS  =  'Rocks')",
        "changes_information": {
            "original_value": "Rocks",
            "synonym": "stones"
        }
    },
    {
        "SQL": "SELECT code FROM boxes WHERE value  >  (SELECT min(value) FROM boxes WHERE CONTENTS  =  'Rocks')",
        "tables": [
            "boxes"
        ],
        "columns": [
            "boxes.contents",
            "boxes.value",
            "boxes.code"
        ],
        "values": [
            {
                "table": "boxes",
                "column": "contents",
                "value": "Rocks",
                "condition": "="
            },
            {
                "table": "",
                "column": "contents",
                "value": "Rocks",
                "condition": "="
            }
        ],
        "db_id": "warehouse_1",
        "source": "spider_test",
        "evidence": "",
        "values_list": [
            "boxes.contents.rocks",
            ".contents.rocks"
        ],
        "original_question": "What are the codes of boxes for which the value is greater than the value of any box that contains Rocks?",
        "question": "What are the codes of boxes for which the value is greater than the value of any box that contains stones?",
        "original_SQL": "SELECT code FROM boxes WHERE value  >  (SELECT min(value) FROM boxes WHERE CONTENTS  =  'Rocks')",
        "changes_information": {
            "original_value": "Rocks",
            "synonym": "stones"
        }
    },
    {
        "SQL": "SELECT T2.spent FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'September Meeting' AND T2.category = 'Advertisement' AND SUBSTR(T1.event_date, 6, 2) = '09'",
        "tables": [
            "budget",
            "event"
        ],
        "columns": [
            "event.event_name",
            "budget.category",
            "budget.link_to_event",
            "event.event_date",
            "event.event_id",
            "budget.spent"
        ],
        "values": [
            {
                "table": "event",
                "column": "event_name",
                "value": "September Meeting",
                "condition": "="
            },
            {
                "table": "budget",
                "column": "category",
                "value": "Advertisement",
                "condition": "="
            }
        ],
        "db_id": "student_club",
        "source": "bird_dev",
        "evidence": "amount spent refers to spent; spend on food in September Meeting refers to category = 'Food' where event_name = 'September Meeting'",
        "values_list": [
            "event.event_name.september meeting",
            "budget.category.advertisement"
        ],
        "original_question": "How much did the Student_Club members spend on food in September Meeting?",
        "question": "How much did the Student_Club members spend on Promotion in September Meeting?",
        "original_SQL": "SELECT T2.spent FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'September Meeting' AND T2.category = 'Food' AND SUBSTR(T1.event_date, 6, 2) = '09'",
        "changes_information": {
            "original_value": "Advertisement",
            "synonym": "Promotion"
        }
    },
    {
        "SQL": "SELECT T2.spent FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'September Meeting' AND T2.category = 'Advertisement' AND SUBSTR(T1.event_date, 6, 2) = '09'",
        "tables": [
            "budget",
            "event"
        ],
        "columns": [
            "event.event_name",
            "budget.category",
            "budget.link_to_event",
            "event.event_date",
            "event.event_id",
            "budget.spent"
        ],
        "values": [
            {
                "table": "event",
                "column": "event_name",
                "value": "September Meeting",
                "condition": "="
            },
            {
                "table": "budget",
                "column": "category",
                "value": "Advertisement",
                "condition": "="
            }
        ],
        "db_id": "student_club",
        "source": "bird_dev",
        "evidence": "amount spent refers to spent; spend on food in September Meeting refers to category = 'Advertisement' where event_name = 'September Meeting'",
        "values_list": [
            "event.event_name.september meeting",
            "budget.category.advertisement"
        ],
        "original_question": "How much did the Student_Club members spend on advertisement in September Meeting?",
        "question": "How much did the Student_Club members spend on Promotion in September Meeting?",
        "original_SQL": "SELECT T2.spent FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'September Meeting' AND T2.category = 'Advertisement' AND SUBSTR(T1.event_date, 6, 2) = '09'",
        "changes_information": {
            "original_value": "Advertisement",
            "synonym": "Promotion"
        }
    },
    {
        "SQL": "SELECT remaining FROM budget WHERE category = 'Advertisement' AND amount = ( SELECT MAX(amount) FROM budget WHERE category = 'Advertisement' )",
        "tables": [
            "budget"
        ],
        "columns": [
            "budget.amount",
            "budget.category"
        ],
        "values": [
            {
                "table": "budget",
                "column": "category",
                "value": "Advertisement",
                "condition": "="
            },
            {
                "table": "",
                "column": "category",
                "value": "Food",
                "condition": "="
            },
            {
                "table": "",
                "column": "category",
                "value": "Food",
                "condition": "="
            }
        ],
        "db_id": "student_club",
        "source": "bird_dev",
        "evidence": "remaining of budget refers to remaining, biggest budget for 'Food' refers to MAX(budget.amount) where category = 'Food'",
        "values_list": [
            "budget.category.advertisement",
            ".category.food",
            ".category.food"
        ],
        "original_question": "With the biggest budget for the \"Food\", what was the remaining of it?",
        "question": "With the biggest budget for the \"Promotion\", what was the remaining of it?",
        "original_SQL": "SELECT remaining FROM budget WHERE category = 'Food' AND amount = ( SELECT MAX(amount) FROM budget WHERE category = 'Food' )",
        "changes_information": {
            "original_value": "Advertisement",
            "synonym": "Promotion"
        }
    },
    {
        "SQL": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Advertisement' ORDER BY T1.spent DESC LIMIT 1",
        "tables": [
            "budget",
            "event"
        ],
        "columns": [
            "event.event_name",
            "budget.category",
            "budget.link_to_event",
            "event.event_id",
            "budget.spent"
        ],
        "values": [
            {
                "table": "budget",
                "column": "category",
                "value": "Advertisement",
                "condition": "="
            }
        ],
        "db_id": "student_club",
        "source": "bird_dev",
        "evidence": "Name of event refers to event_name; highest amount spent on advertisement refers to MAX(spent) where category = 'Advertisement'",
        "values_list": [
            "budget.category.advertisement"
        ],
        "original_question": "Name the event with the highest amount spent on advertisement.",
        "question": "Name the event with the highest amount spent on Promotion.",
        "original_SQL": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Advertisement' ORDER BY T1.spent DESC LIMIT 1",
        "changes_information": {
            "original_value": "Advertisement",
            "synonym": "Promotion"
        }
    },
    {
        "SQL": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T2.category = 'Advertisement' AND T3.cost < (SELECT AVG(cost) FROM expense)",
        "tables": [
            "budget",
            "event",
            "expense"
        ],
        "columns": [
            "event.event_name",
            "expense.cost",
            "budget.category",
            "budget.link_to_event",
            "budget.budget_id",
            "expense.link_to_budget",
            "event.event_id"
        ],
        "values": [
            {
                "table": "budget",
                "column": "category",
                "value": "Advertisement",
                "condition": "="
            }
        ],
        "db_id": "student_club",
        "source": "bird_dev",
        "evidence": "name of events refers to event_name; less than average parking cost refers to cost < DIVIDE(SUM(cost), COUNT(event_id)) where category = 'Parking'",
        "values_list": [
            "budget.category.advertisement"
        ],
        "original_question": "List the name of events with less than average parking cost.",
        "question": "List the name of events with less than average Promotion cost.",
        "original_SQL": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T2.category = 'Parking' AND T3.cost < (SELECT AVG(cost) FROM expense)",
        "changes_information": {
            "original_value": "Advertisement",
            "synonym": "Promotion"
        }
    },
    {
        "SQL": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.category = 'Advertisement'",
        "tables": [
            "budget",
            "event"
        ],
        "columns": [
            "event.event_id",
            "budget.link_to_event",
            "event.event_name",
            "budget.category"
        ],
        "values": [
            {
                "table": "budget",
                "column": "category",
                "value": "Advertisement",
                "condition": "="
            }
        ],
        "db_id": "student_club",
        "source": "bird_dev",
        "evidence": "budgeted for food refers to category = 'Food'",
        "values_list": [
            "budget.category.advertisement"
        ],
        "original_question": "List the event names which were budgeted for the food.",
        "question": "List the event names which were budgeted for the Promotion.",
        "original_SQL": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.category = 'Food'",
        "changes_information": {
            "original_value": "Advertisement",
            "synonym": "Promotion"
        }
    },
    {
        "SQL": "SELECT SUM(T1.spent), T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Advertisement' GROUP BY T2.event_name",
        "tables": [
            "budget",
            "event"
        ],
        "columns": [
            "event.event_name",
            "budget.category",
            "budget.link_to_event",
            "event.event_id",
            "budget.spent"
        ],
        "values": [
            {
                "table": "budget",
                "column": "category",
                "value": "Advertisement",
                "condition": "="
            }
        ],
        "db_id": "student_club",
        "source": "bird_dev",
        "evidence": "total amount spent = SUM(spent) where category = 'Speaker Gifts'",
        "values_list": [
            "budget.category.speaker gifts"
        ],
        "original_question": "Calculate the total amount spent on speaker gifts and list the name of the event they were spent on.",
        "question": "Calculate the total amount spent on Promotion and list the name of the event they were spent on.",
        "original_SQL": "SELECT SUM(T1.spent), T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Speaker Gifts' GROUP BY T2.event_name",
        "changes_information": {
            "original_value": "Advertisement",
            "synonym": "Promotion"
        }
    },
    {
        "SQL": "SELECT id FROM cards WHERE frameEffects = 'inverted' GROUP BY id",
        "tables": [
            "cards"
        ],
        "columns": [
            "cards.id",
            "cards.frameeffects"
        ],
        "values": [
            {
                "table": "cards",
                "column": "frameeffects",
                "value": "inverted",
                "condition": "="
            }
        ],
        "db_id": "card_games",
        "source": "bird_dev",
        "evidence": "\nframe effect as extendedart refers to frameEffects = 'extendedart'\n",
        "values_list": [
            "cards.frameeffects.inverted"
        ],
        "original_question": "How many cards have frame effect as extendedart? List out the id of those cards.",
        "question": "How many cards have frame effect as reversed? List out the id of those cards.",
        "original_SQL": "SELECT id FROM cards WHERE frameEffects = 'extendedart' GROUP BY id",
        "changes_information": {
            "original_value": "inverted",
            "synonym": "reversed"
        }
    },
    {
        "SQL": "SELECT layout FROM cards WHERE keywords = 'Defender'",
        "tables": [
            "cards"
        ],
        "columns": [
            "cards.keywords",
            "cards.layout"
        ],
        "values": [
            {
                "table": "cards",
                "column": "keywords",
                "value": "Defender",
                "condition": "="
            }
        ],
        "db_id": "card_games",
        "source": "bird_dev",
        "evidence": "",
        "values_list": [
            "cards.keywords.defender"
        ],
        "original_question": "What are the card layout of cards with keyword of flying?",
        "question": "What are the card layout of cards with keyword of Protector?",
        "original_SQL": "SELECT layout FROM cards WHERE keywords = 'Flying'",
        "changes_information": {
            "original_value": "Defender",
            "synonym": "Protector"
        }
    },
    {
        "SQL": "SELECT T1.id, T2.date FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Instant'",
        "tables": [
            "rulings",
            "cards"
        ],
        "columns": [
            "cards.originaltype",
            "cards.id",
            "rulings.date",
            "cards.uuid",
            "rulings.uuid"
        ],
        "values": [
            {
                "table": "cards",
                "column": "originaltype",
                "value": "Instant",
                "condition": "="
            }
        ],
        "db_id": "card_games",
        "source": "bird_dev",
        "evidence": "Creature - Elf is the originalType;",
        "values_list": [
            "cards.originaltype.creature - elf"
        ],
        "original_question": "List down the name of cards with original types of Creature - Elf and the date of rulings for these cards.",
        "question": "List down the name of cards with original types of immediate and the date of rulings for these cards.",
        "original_SQL": "SELECT T1.id, T2.date FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Creature - Elf'",
        "changes_information": {
            "original_value": "Instant",
            "synonym": "immediate"
        }
    },
    {
        "SQL": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Instant' AND T1.colors = 'B'",
        "tables": [
            "cards",
            "foreign_data"
        ],
        "columns": [
            "cards.originaltype",
            "cards.name",
            "cards.colors",
            "foreign_data.uuid",
            "cards.uuid"
        ],
        "values": [
            {
                "table": "cards",
                "column": "originaltype",
                "value": "Instant",
                "condition": "="
            },
            {
                "table": "cards",
                "column": "colors",
                "value": "B",
                "condition": "="
            }
        ],
        "db_id": "card_games",
        "source": "bird_dev",
        "evidence": "Artifact card refers to originalType = 'Artifact'; black color refers to colors = 'B'; foreign language refers to language in foreign_data",
        "values_list": [
            "cards.originaltype.instant",
            "cards.colors.b"
        ],
        "original_question": "Among the Artifact cards, which are black color and comes with foreign languague translation?",
        "question": "Among the immediate cards, which are black color and comes with foreign languague translation?",
        "original_SQL": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Artifact' AND T1.colors = 'B'",
        "changes_information": {
            "original_value": "Instant",
            "synonym": "immediate"
        }
    },
    {
        "SQL": "SELECT DISTINCT purchaseUrls FROM cards WHERE promoTypes = 'prerelease'",
        "tables": [
            "cards"
        ],
        "columns": [
            "cards.purchaseurls",
            "cards.promotypes"
        ],
        "values": [
            {
                "table": "cards",
                "column": "promotypes",
                "value": "prerelease",
                "condition": "="
            }
        ],
        "db_id": "card_games",
        "source": "bird_dev",
        "evidence": "promotional type of \"bundle\" refers to promoTypes = 'bundle'; websites refers to purchaseUrls",
        "values_list": [
            "cards.promotypes.prerelease"
        ],
        "original_question": "Please list the websites where I can purchase the cards that have the promotional type of \"bundle\".",
        "question": "Please list the websites where I can purchase the cards that have the promotional type of \"prelaunch\".",
        "original_SQL": "SELECT DISTINCT purchaseUrls FROM cards WHERE promoTypes = 'bundle'",
        "changes_information": {
            "original_value": "prerelease",
            "synonym": "prelaunch"
        }
    },
    {
        "SQL": "SELECT DISTINCT purchaseUrls FROM cards WHERE promoTypes = 'bundle'",
        "tables": [
            "cards"
        ],
        "columns": [
            "cards.purchaseurls",
            "cards.promotypes"
        ],
        "values": [
            {
                "table": "cards",
                "column": "promotypes",
                "value": "bundle",
                "condition": "="
            }
        ],
        "db_id": "card_games",
        "source": "bird_dev",
        "evidence": "promotional type of \"bundle\" refers to promoTypes = 'bundle'; websites refers to purchaseUrls",
        "values_list": [
            "cards.promotypes.bundle"
        ],
        "original_question": "Please list the websites where I can purchase the cards that have the promotional type of \"bundle\".",
        "question": "Please list the websites where I can purchase the cards that have the promotional type of \"package\".",
        "original_SQL": "SELECT DISTINCT purchaseUrls FROM cards WHERE promoTypes = 'bundle'",
        "changes_information": {
            "original_value": "bundle",
            "synonym": "package"
        }
    },
    {
        "SQL": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Germany'",
        "tables": [
            "circuits",
            "races"
        ],
        "columns": [
            "circuits.circuitid",
            "races.name",
            "circuits.country",
            "races.circuitid"
        ],
        "values": [
            {
                "table": "circuits",
                "column": "country",
                "value": "Germany",
                "condition": "="
            }
        ],
        "db_id": "formula_1",
        "source": "bird_dev",
        "evidence": "Germany is a name of country;",
        "values_list": [
            "circuits.country.germany"
        ],
        "original_question": "Please give the name of the race held on the circuits in Germany.",
        "question": "Please give the name of the race held on the circuits in Deutschland.",
        "original_SQL": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Germany'",
        "changes_information": {
            "original_value": "Germany",
            "synonym": "Deutschland"
        }
    },
    {
        "SQL": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Germany'",
        "tables": [
            "circuits",
            "races"
        ],
        "columns": [
            "circuits.circuitid",
            "races.name",
            "circuits.country",
            "races.circuitid"
        ],
        "values": [
            {
                "table": "circuits",
                "column": "country",
                "value": "Germany",
                "condition": "="
            }
        ],
        "db_id": "formula_1",
        "source": "bird_dev",
        "evidence": "Spain is a name of country;",
        "values_list": [
            "circuits.country.germany"
        ],
        "original_question": "Please give the names of the races held on the circuits in Spain.",
        "question": "Please give the names of the races held on the circuits in Deutschland.",
        "original_SQL": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Spain'",
        "changes_information": {
            "original_value": "Germany",
            "synonym": "Deutschland"
        }
    },
    {
        "SQL": "SELECT T1.name, T1.location, T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Germany' AND T2.year = 2006",
        "tables": [
            "circuits",
            "races"
        ],
        "columns": [
            "races.circuitid",
            "circuits.location",
            "circuits.country",
            "races.year",
            "races.name",
            "circuits.circuitid",
            "circuits.name"
        ],
        "values": [
            {
                "table": "circuits",
                "column": "country",
                "value": "Germany",
                "condition": "="
            },
            {
                "table": "races",
                "column": "year",
                "value": "2006",
                "condition": "="
            }
        ],
        "db_id": "formula_1",
        "source": "bird_dev",
        "evidence": "",
        "values_list": [
            "circuits.country.germany",
            "races.year.2006"
        ],
        "original_question": "List circuits in USA which hosted f1 races in 2006. State the name and location of circuit and the name of the race it hosted.",
        "question": "List circuits in Deutschland which hosted f1 races in 2006. State the name and location of circuit and the name of the race it hosted.",
        "original_SQL": "SELECT T1.name, T1.location, T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'USA' AND T2.year = 2006",
        "changes_information": {
            "original_value": "Germany",
            "synonym": "Deutschland"
        }
    },
    {
        "SQL": "SELECT DISTINCT location, lat, lng FROM circuits WHERE country = 'Germany'",
        "tables": [
            "circuits"
        ],
        "columns": [
            "circuits.lat",
            "circuits.lng",
            "circuits.country",
            "circuits.location"
        ],
        "values": [
            {
                "table": "circuits",
                "column": "country",
                "value": "Germany",
                "condition": "="
            }
        ],
        "db_id": "formula_1",
        "source": "bird_dev",
        "evidence": "location coordinates refers to (lat,lng); Austria refers to country = 'Austria';",
        "values_list": [
            "circuits.country.germany"
        ],
        "original_question": "How many times the circuits were held in Austria? Please give their location and coordinates.",
        "question": "How many times the circuits were held in Deutschland? Please give their location and coordinates.",
        "original_SQL": "SELECT DISTINCT location, lat, lng FROM circuits WHERE country = 'Austria'",
        "changes_information": {
            "original_value": "Germany",
            "synonym": "Deutschland"
        }
    },
    {
        "SQL": "WITH fastest_lap_times AS (SELECT T1.raceId, T1.FastestLapTime, (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) as time_in_seconds FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL ) SELECT T1.FastestLapTime as lap_record FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId INNER JOIN (SELECT MIN(fastest_lap_times.time_in_seconds) as min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T3.country = 'Germany' ) AS T4 ON (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) = T4.min_time_in_seconds LIMIT 1",
        "tables": [
            "results",
            "circuits",
            "races"
        ],
        "columns": [
            "races.circuitid",
            "races.raceid",
            "results.fastestlaptime",
            "circuits.country",
            "results.raceid",
            "circuits.circuitid"
        ],
        "values": [
            {
                "table": "circuits",
                "column": "country",
                "value": "Germany",
                "condition": "="
            },
            {
                "table": "circuits",
                "column": "country",
                "value": "Italy",
                "condition": "="
            }
        ],
        "db_id": "formula_1",
        "source": "bird_dev",
        "evidence": "lap record means the fastest time recorded which refers to time",
        "values_list": [
            "circuits.country.germany",
            "circuits.country.italy"
        ],
        "original_question": "Please list the lap records for the circuits in Italy.",
        "question": "Please list the lap records for the circuits in Deutschland.",
        "original_SQL": "WITH fastest_lap_times AS (SELECT T1.raceId, T1.FastestLapTime, (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) as time_in_seconds FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL ) SELECT T1.FastestLapTime as lap_record FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId INNER JOIN (SELECT MIN(fastest_lap_times.time_in_seconds) as min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T3.country = 'Italy' ) AS T4 ON (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) = T4.min_time_in_seconds LIMIT 1",
        "changes_information": {
            "original_value": "Germany",
            "synonym": "Deutschland"
        }
    },
    {
        "SQL": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Netherlands'",
        "tables": [
            "circuits",
            "races"
        ],
        "columns": [
            "circuits.circuitid",
            "races.name",
            "circuits.country",
            "races.circuitid"
        ],
        "values": [
            {
                "table": "circuits",
                "column": "country",
                "value": "Netherlands",
                "condition": "="
            }
        ],
        "db_id": "formula_1",
        "source": "bird_dev",
        "evidence": "Germany is a name of country;",
        "values_list": [
            "circuits.country.netherlands"
        ],
        "original_question": "Please give the name of the race held on the circuits in Germany.",
        "question": "Please give the name of the race held on the circuits in Holland.",
        "original_SQL": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Germany'",
        "changes_information": {
            "original_value": "Netherlands",
            "synonym": "Holland"
        }
    },
    {
        "SQL": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Netherlands'",
        "tables": [
            "circuits",
            "races"
        ],
        "columns": [
            "circuits.circuitid",
            "races.name",
            "circuits.country",
            "races.circuitid"
        ],
        "values": [
            {
                "table": "circuits",
                "column": "country",
                "value": "Netherlands",
                "condition": "="
            }
        ],
        "db_id": "formula_1",
        "source": "bird_dev",
        "evidence": "Spain is a name of country;",
        "values_list": [
            "circuits.country.netherlands"
        ],
        "original_question": "Please give the names of the races held on the circuits in Spain.",
        "question": "Please give the names of the races held on the circuits in Holland.",
        "original_SQL": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Spain'",
        "changes_information": {
            "original_value": "Netherlands",
            "synonym": "Holland"
        }
    },
    {
        "SQL": "SELECT DISTINCT location, lat, lng FROM circuits WHERE country = 'Netherlands'",
        "tables": [
            "circuits"
        ],
        "columns": [
            "circuits.lat",
            "circuits.lng",
            "circuits.country",
            "circuits.location"
        ],
        "values": [
            {
                "table": "circuits",
                "column": "country",
                "value": "Netherlands",
                "condition": "="
            }
        ],
        "db_id": "formula_1",
        "source": "bird_dev",
        "evidence": "location coordinates refers to (lat,lng); Austria refers to country = 'Austria';",
        "values_list": [
            "circuits.country.netherlands"
        ],
        "original_question": "How many times the circuits were held in Austria? Please give their location and coordinates.",
        "question": "How many times the circuits were held in Holland? Please give their location and coordinates.",
        "original_SQL": "SELECT DISTINCT location, lat, lng FROM circuits WHERE country = 'Austria'",
        "changes_information": {
            "original_value": "Netherlands",
            "synonym": "Holland"
        }
    },
    {
        "SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Blond'",
        "tables": [
            "superhero",
            "colour"
        ],
        "columns": [
            "superhero.hair_colour_id",
            "superhero.superhero_name",
            "colour.colour",
            "colour.id",
            "superhero.eye_colour_id"
        ],
        "values": [
            {
                "table": "colour",
                "column": "colour",
                "value": "Blue",
                "condition": "="
            },
            {
                "table": "colour",
                "column": "colour",
                "value": "Blond",
                "condition": "="
            }
        ],
        "db_id": "superhero",
        "source": "bird_dev",
        "evidence": "blue eyes refers to colour = 'Blue' and eye_colour_id = colour.id; blond hair refers to colour = 'Blond' and hair_colour_id = colour.id; super power of \"Agility\" refers to power_name = 'Agility'",
        "values_list": [
            "colour.colour.blue",
            "colour.colour.blond"
        ],
        "original_question": "Please list the superhero names of all the superheroes that have blue eyes and blond hair.",
        "question": "Please list the superhero names of all the superheroes that have azure eyes and blond hair.",
        "original_SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Blond'",
        "changes_information": {
            "original_value": "Blue",
            "synonym": "azure"
        }
    },
    {
        "SQL": "SELECT T1.height_cm FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Blue'",
        "tables": [
            "superhero",
            "colour"
        ],
        "columns": [
            "colour.id",
            "superhero.eye_colour_id",
            "colour.colour",
            "superhero.height_cm"
        ],
        "values": [
            {
                "table": "colour",
                "column": "colour",
                "value": "Blue",
                "condition": "="
            }
        ],
        "db_id": "superhero",
        "source": "bird_dev",
        "evidence": "heights of the heroes refers to height_cm; eye colours are amber refers to colour.colour = 'Amber' WHERE eye_colour_id = colour.id;",
        "values_list": [
            "colour.colour.blue"
        ],
        "original_question": "Provide the heights of the heroes whose eye colours are amber.",
        "question": "Provide the heights of the heroes whose eye colours are azure.",
        "original_SQL": "SELECT T1.height_cm FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Amber'",
        "changes_information": {
            "original_value": "Blue",
            "synonym": "azure"
        }
    },
    {
        "SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id AND T1.hair_colour_id = T2.id WHERE T2.colour = 'Blue'",
        "tables": [
            "superhero",
            "colour"
        ],
        "columns": [
            "superhero.hair_colour_id",
            "superhero.superhero_name",
            "colour.colour",
            "colour.id",
            "superhero.eye_colour_id"
        ],
        "values": [
            {
                "table": "colour",
                "column": "colour",
                "value": "Blue",
                "condition": "="
            }
        ],
        "db_id": "superhero",
        "source": "bird_dev",
        "evidence": "heroes' names refers to superhero_name; eyes and hair colours are both black refers to eye_colour_id AND hair_colour_id WHERE colour.colour = 'Black';",
        "values_list": [
            "colour.colour.blue"
        ],
        "original_question": "List the heroes' names whose eyes and hair colours are both black.",
        "question": "List the heroes' names whose eyes and hair colours are both azure.",
        "original_SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id AND T1.hair_colour_id = T2.id WHERE T2.colour = 'Black'",
        "changes_information": {
            "original_value": "Blue",
            "synonym": "azure"
        }
    },
    {
        "SQL": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id WHERE T3.colour = 'Blue'",
        "tables": [
            "superhero",
            "colour"
        ],
        "columns": [
            "colour.id",
            "superhero.eye_colour_id",
            "superhero.skin_colour_id",
            "colour.colour"
        ],
        "values": [
            {
                "table": "colour",
                "column": "colour",
                "value": "Blue",
                "condition": "="
            }
        ],
        "db_id": "superhero",
        "source": "bird_dev",
        "evidence": "skin colours are gold refers to colour.colour = 'Gold' WHERE skin_colour_id = colour.id;",
        "values_list": [
            "colour.colour.blue"
        ],
        "original_question": "Provide the eye colours of the heroes whose skin colours are gold.",
        "question": "Provide the eye colours of the heroes whose skin colours are azure.",
        "original_SQL": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id WHERE T3.colour = 'Gold'",
        "changes_information": {
            "original_value": "Blue",
            "synonym": "azure"
        }
    },
    {
        "SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Brown'",
        "tables": [
            "superhero",
            "colour"
        ],
        "columns": [
            "superhero.hair_colour_id",
            "superhero.superhero_name",
            "colour.colour",
            "colour.id",
            "superhero.eye_colour_id"
        ],
        "values": [
            {
                "table": "colour",
                "column": "colour",
                "value": "Blue",
                "condition": "="
            },
            {
                "table": "colour",
                "column": "colour",
                "value": "Brown",
                "condition": "="
            }
        ],
        "db_id": "superhero",
        "source": "bird_dev",
        "evidence": "which superheroes refers to superhero_name; blue eyes refers to color = 'Blue' and color.id = eye_colour_id; brown hair refers to color = 'Brown' and color.id = hair_colour_id;",
        "values_list": [
            "colour.colour.blue",
            "colour.colour.brown"
        ],
        "original_question": "Which superheroes have blue eyes with brown hair?",
        "question": "Which superheroes have azure eyes with brown hair?",
        "original_SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Brown'",
        "changes_information": {
            "original_value": "Blue",
            "synonym": "azure"
        }
    },
    {
        "SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Blue' LIMIT 5",
        "tables": [
            "superhero",
            "colour"
        ],
        "columns": [
            "superhero.superhero_name",
            "superhero.eye_colour_id",
            "colour.id",
            "colour.colour"
        ],
        "values": [
            {
                "table": "colour",
                "column": "colour",
                "value": "Blue",
                "condition": "="
            }
        ],
        "db_id": "superhero",
        "source": "bird_dev",
        "evidence": "blue eyes refers to colour.colour = 'Blue' WHERE eye_colour_id = colour.id; Name of superheroes refers to superhero_name;",
        "values_list": [
            "colour.colour.blue"
        ],
        "original_question": "List down at least five full names of superheroes with blue eyes.",
        "question": "List down at least five full names of superheroes with azure eyes.",
        "original_SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Blue' LIMIT 5",
        "changes_information": {
            "original_value": "Blue",
            "synonym": "azure"
        }
    },
    {
        "SQL": "SELECT T3.race FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.hair_colour_id = T2.id INNER JOIN race AS T3 ON T1.race_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T2.colour = 'Blue' AND T4.gender = 'Male'",
        "tables": [
            "race",
            "superhero",
            "gender",
            "colour"
        ],
        "columns": [
            "gender.gender",
            "race.id",
            "superhero.hair_colour_id",
            "gender.id",
            "superhero.gender_id",
            "colour.colour",
            "superhero.race_id",
            "colour.id",
            "race.race"
        ],
        "values": [
            {
                "table": "colour",
                "column": "colour",
                "value": "Blue",
                "condition": "="
            },
            {
                "table": "gender",
                "column": "gender",
                "value": "Male",
                "condition": "="
            }
        ],
        "db_id": "superhero",
        "source": "bird_dev",
        "evidence": "blue-haired refers to colour.colour = 'blue' WHERE hair_colour_id = colour.id; male refers to gender = 'male';",
        "values_list": [
            "colour.colour.blue",
            "gender.gender.male"
        ],
        "original_question": "Give the race of the blue-haired male superhero.",
        "question": "Give the race of the azure-haired male superhero.",
        "original_SQL": "SELECT T3.race FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.hair_colour_id = T2.id INNER JOIN race AS T3 ON T1.race_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T2.colour = 'Blue' AND T4.gender = 'Male'",
        "changes_information": {
            "original_value": "Blue",
            "synonym": "azure"
        }
    },
    {
        "SQL": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.weight_kg < 100 AND T2.colour = 'Blue'",
        "tables": [
            "superhero",
            "colour"
        ],
        "columns": [
            "superhero.weight_kg",
            "superhero.full_name",
            "colour.colour",
            "colour.id",
            "superhero.eye_colour_id"
        ],
        "values": [
            {
                "table": "superhero",
                "column": "weight_kg",
                "value": "100",
                "condition": "<"
            },
            {
                "table": "colour",
                "column": "colour",
                "value": "Blue",
                "condition": "="
            }
        ],
        "db_id": "superhero",
        "source": "bird_dev",
        "evidence": "weight less than 100 refers to weight_kg < 100",
        "values_list": [
            "superhero.weight_kg.100",
            "colour.colour.blue"
        ],
        "original_question": "In superheroes with weight less than 100, list the full name of the superheroes with brown eyes.",
        "question": "In superheroes with weight less than 100, list the full name of the superheroes with azure eyes.",
        "original_SQL": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.weight_kg < 100 AND T2.colour = 'Brown'",
        "changes_information": {
            "original_value": "Blue",
            "synonym": "azure"
        }
    },
    {
        "SQL": "SELECT T1.name FROM staff AS T1 JOIN conference_participation AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.role  =  'Participant' INTERSECT SELECT T1.name FROM staff AS T1 JOIN conference_participation AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.role  =  'Sponsor'",
        "tables": [
            "staff",
            "conference_participation"
        ],
        "columns": [
            "conference_participation.staff_id",
            "staff.staff_id",
            "conference_participation.role",
            "staff.name"
        ],
        "values": [
            {
                "table": "conference_participation",
                "column": "role",
                "value": "Participant",
                "condition": "="
            },
            {
                "table": "conference_participation",
                "column": "role",
                "value": "Sponsor",
                "condition": "="
            }
        ],
        "db_id": "conference",
        "source": "spider_test",
        "evidence": "",
        "values_list": [
            "conference_participation.role.participant",
            "conference_participation.role.sponsor"
        ],
        "original_question": "Show all staff names who have been both speaker and sponsor in some conference.",
        "question": "Show all staff names who have been both Attendee and sponsor in some conference.",
        "original_SQL": "SELECT T1.name FROM staff AS T1 JOIN conference_participation AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.role  =  'Speaker' INTERSECT SELECT T1.name FROM staff AS T1 JOIN conference_participation AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.role  =  'Sponsor'",
        "changes_information": {
            "original_value": "Participant",
            "synonym": "Attendee"
        }
    },
    {
        "SQL": "SELECT T1.name FROM staff AS T1 JOIN conference_participation AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.role  =  'Participant' INTERSECT SELECT T1.name FROM staff AS T1 JOIN conference_participation AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.role  =  'Sponsor'",
        "tables": [
            "staff",
            "conference_participation"
        ],
        "columns": [
            "conference_participation.staff_id",
            "staff.staff_id",
            "conference_participation.role",
            "staff.name"
        ],
        "values": [
            {
                "table": "conference_participation",
                "column": "role",
                "value": "Participant",
                "condition": "="
            },
            {
                "table": "conference_participation",
                "column": "role",
                "value": "Sponsor",
                "condition": "="
            }
        ],
        "db_id": "conference",
        "source": "spider_test",
        "evidence": "",
        "values_list": [
            "conference_participation.role.participant",
            "conference_participation.role.sponsor"
        ],
        "original_question": "What are the names of the staff members who have been both a speaker and a sponsor at some conference?",
        "question": "What are the names of the staff members who have been both a Attendee and a sponsor at some conference?",
        "original_SQL": "SELECT T1.name FROM staff AS T1 JOIN conference_participation AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.role  =  'Speaker' INTERSECT SELECT T1.name FROM staff AS T1 JOIN conference_participation AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.role  =  'Sponsor'",
        "changes_information": {
            "original_value": "Participant",
            "synonym": "Attendee"
        }
    },
    {
        "SQL": "SELECT T1.url FROM constructors AS T1 INNER JOIN constructorStandings AS T2 on T1.constructorId = T2.constructorId WHERE T1.nationality = 'Swiss' ORDER BY T2.points DESC LIMIT 1",
        "tables": [
            "constructors",
            "constructorstandings"
        ],
        "columns": [
            "constructorstandings.constructorid",
            "constructors.nationality",
            "constructorstandings.points",
            "constructors.constructorid",
            "constructors.url"
        ],
        "values": [
            {
                "table": "constructors",
                "column": "nationality",
                "value": "Swiss",
                "condition": "="
            }
        ],
        "db_id": "formula_1",
        "source": "bird_dev",
        "evidence": "introduction website refers to url; Italian is a nationality",
        "values_list": [
            "constructors.nationality.swiss"
        ],
        "original_question": "Which of the Italian constructor got the highest point to date? Give its introduction website?",
        "question": "Which of the Helvetic constructor got the highest point to date? Give its introduction website?",
        "original_SQL": "SELECT T1.url FROM constructors AS T1 INNER JOIN constructorStandings AS T2 on T1.constructorId = T2.constructorId WHERE T1.nationality = 'Italian' ORDER BY T2.points DESC LIMIT 1",
        "changes_information": {
            "original_value": "Swiss",
            "synonym": "Helvetic"
        }
    },
    {
        "SQL": "SELECT t2.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Netherlands'",
        "tables": [
            "league",
            "country"
        ],
        "columns": [
            "country.name",
            "country.id",
            "league.country_id",
            "league.name"
        ],
        "values": [
            {
                "table": "country",
                "column": "name",
                "value": "Netherlands",
                "condition": "="
            }
        ],
        "db_id": "european_football_2",
        "source": "bird_dev",
        "evidence": "name of the football league refers to League.name;",
        "values_list": [
            "country.name.netherlands"
        ],
        "original_question": "What is the name of the football league in the country of Netherlands?",
        "question": "What is the name of the football league in the country of Holland?",
        "original_SQL": "SELECT t2.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Netherlands'",
        "changes_information": {
            "original_value": "Netherlands",
            "synonym": "Holland"
        }
    },
    {
        "SQL": "SELECT t2.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Netherlands'",
        "tables": [
            "league",
            "country"
        ],
        "columns": [
            "country.name",
            "country.id",
            "league.country_id",
            "league.name"
        ],
        "values": [
            {
                "table": "country",
                "column": "name",
                "value": "Netherlands",
                "condition": "="
            }
        ],
        "db_id": "european_football_2",
        "source": "bird_dev",
        "evidence": "Germany refers to Country.name = 'Germany';",
        "values_list": [
            "country.name.netherlands"
        ],
        "original_question": "Please list the leagues from Germany.",
        "question": "Please list the leagues from Holland.",
        "original_SQL": "SELECT t2.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Germany'",
        "changes_information": {
            "original_value": "Netherlands",
            "synonym": "Holland"
        }
    },
    {
        "SQL": "SELECT t3.player_name FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id INNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id WHERE t1.name = 'Netherlands'",
        "tables": [
            "match",
            "player",
            "country"
        ],
        "columns": [
            "player.player_name",
            "match.home_player_1",
            "country.name",
            "country.id",
            "match.country_id",
            "player.player_api_id"
        ],
        "values": [
            {
                "table": "country",
                "column": "name",
                "value": "Netherlands",
                "condition": "="
            }
        ],
        "db_id": "european_football_2",
        "source": "bird_dev",
        "evidence": "name of players refers to player_name; Belgium is name of country",
        "values_list": [
            "country.name.netherlands"
        ],
        "original_question": "State the name of players who came from Belgium.",
        "question": "State the name of players who came from Holland.",
        "original_SQL": "SELECT t3.player_name FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id INNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id WHERE t1.name = 'Belgium'",
        "changes_information": {
            "original_value": "Netherlands",
            "synonym": "Holland"
        }
    },
    {
        "SQL": "SELECT DISTINCT T1.product_name ,  T1.product_price ,  T1.product_description FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T2.order_id  =  T3.order_id JOIN Customers AS T4 ON T3.customer_id  =  T4.customer_id WHERE T4.gender_code  =  'Female'",
        "tables": [
            "orders",
            "products",
            "order_items",
            "customers"
        ],
        "columns": [
            "products.product_name",
            "customers.gender_code",
            "customers.customer_id",
            "orders.order_id",
            "products.product_description",
            "order_items.order_id",
            "products.product_id",
            "products.product_price",
            "order_items.product_id",
            "orders.customer_id"
        ],
        "values": [
            {
                "table": "customers",
                "column": "gender_code",
                "value": "Female",
                "condition": "="
            }
        ],
        "db_id": "e_commerce",
        "source": "spider_test",
        "evidence": "",
        "values_list": [
            "customers.gender_code.female"
        ],
        "original_question": "List all the distinct product names, price and descriptions which are bought by female customers.",
        "question": "List all the distinct product names, price and descriptions which are bought by woman customers.",
        "original_SQL": "SELECT DISTINCT T1.product_name ,  T1.product_price ,  T1.product_description FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T2.order_id  =  T3.order_id JOIN Customers AS T4 ON T3.customer_id  =  T4.customer_id WHERE T4.gender_code  =  'Female'",
        "changes_information": {
            "original_value": "Female",
            "synonym": "woman"
        }
    },
    {
        "SQL": "SELECT DISTINCT T1.product_name ,  T1.product_price ,  T1.product_description FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T2.order_id  =  T3.order_id JOIN Customers AS T4 ON T3.customer_id  =  T4.customer_id WHERE T4.gender_code  =  'Female'",
        "tables": [
            "orders",
            "products",
            "order_items",
            "customers"
        ],
        "columns": [
            "products.product_name",
            "customers.gender_code",
            "customers.customer_id",
            "orders.order_id",
            "products.product_description",
            "order_items.order_id",
            "products.product_id",
            "products.product_price",
            "order_items.product_id",
            "orders.customer_id"
        ],
        "values": [
            {
                "table": "customers",
                "column": "gender_code",
                "value": "Female",
                "condition": "="
            }
        ],
        "db_id": "e_commerce",
        "source": "spider_test",
        "evidence": "",
        "values_list": [
            "customers.gender_code.female"
        ],
        "original_question": "What are the different names, prices, and descriptions for all products bought by female customers?",
        "question": "What are the different names, prices, and descriptions for all products bought by woman customers?",
        "original_SQL": "SELECT DISTINCT T1.product_name ,  T1.product_price ,  T1.product_description FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T2.order_id  =  T3.order_id JOIN Customers AS T4 ON T3.customer_id  =  T4.customer_id WHERE T4.gender_code  =  'Female'",
        "changes_information": {
            "original_value": "Female",
            "synonym": "woman"
        }
    },
    {
        "SQL": "SELECT DISTINCT T1.product_name ,  T1.product_price ,  T1.product_description FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T2.order_id  =  T3.order_id JOIN Customers AS T4 ON T3.customer_id  =  T4.customer_id WHERE T4.gender_code  =  'Male'",
        "tables": [
            "orders",
            "products",
            "order_items",
            "customers"
        ],
        "columns": [
            "products.product_name",
            "customers.gender_code",
            "customers.customer_id",
            "orders.order_id",
            "products.product_description",
            "order_items.order_id",
            "products.product_id",
            "products.product_price",
            "order_items.product_id",
            "orders.customer_id"
        ],
        "values": [
            {
                "table": "customers",
                "column": "gender_code",
                "value": "Male",
                "condition": "="
            }
        ],
        "db_id": "e_commerce",
        "source": "spider_test",
        "evidence": "",
        "values_list": [
            "customers.gender_code.male"
        ],
        "original_question": "List all the distinct product names, price and descriptions which are bought by female customers.",
        "question": "List all the distinct product names, price and descriptions which are bought by man customers.",
        "original_SQL": "SELECT DISTINCT T1.product_name ,  T1.product_price ,  T1.product_description FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T2.order_id  =  T3.order_id JOIN Customers AS T4 ON T3.customer_id  =  T4.customer_id WHERE T4.gender_code  =  'Female'",
        "changes_information": {
            "original_value": "Male",
            "synonym": "man"
        }
    },
    {
        "SQL": "SELECT DISTINCT T1.product_name ,  T1.product_price ,  T1.product_description FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T2.order_id  =  T3.order_id JOIN Customers AS T4 ON T3.customer_id  =  T4.customer_id WHERE T4.gender_code  =  'Male'",
        "tables": [
            "orders",
            "products",
            "order_items",
            "customers"
        ],
        "columns": [
            "products.product_name",
            "customers.gender_code",
            "customers.customer_id",
            "orders.order_id",
            "products.product_description",
            "order_items.order_id",
            "products.product_id",
            "products.product_price",
            "order_items.product_id",
            "orders.customer_id"
        ],
        "values": [
            {
                "table": "customers",
                "column": "gender_code",
                "value": "Male",
                "condition": "="
            }
        ],
        "db_id": "e_commerce",
        "source": "spider_test",
        "evidence": "",
        "values_list": [
            "customers.gender_code.male"
        ],
        "original_question": "What are the different names, prices, and descriptions for all products bought by female customers?",
        "question": "What are the different names, prices, and descriptions for all products bought by man customers?",
        "original_SQL": "SELECT DISTINCT T1.product_name ,  T1.product_price ,  T1.product_description FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T2.order_id  =  T3.order_id JOIN Customers AS T4 ON T3.customer_id  =  T4.customer_id WHERE T4.gender_code  =  'Female'",
        "changes_information": {
            "original_value": "Male",
            "synonym": "man"
        }
    },
    {
        "SQL": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'",
        "tables": [
            "students",
            "degree_programs",
            "student_enrolment"
        ],
        "columns": [
            "students.middle_name",
            "students.last_name",
            "students.student_id",
            "students.first_name",
            "student_enrolment.degree_program_id",
            "student_enrolment.student_id",
            "degree_programs.degree_summary_name",
            "degree_programs.degree_program_id"
        ],
        "values": [
            {
                "table": "degree_programs",
                "column": "degree_summary_name",
                "value": "Bachelor",
                "condition": "="
            }
        ],
        "db_id": "student_transcripts_tracking",
        "source": "spider_dev",
        "evidence": "",
        "values_list": [
            "degree_programs.degree_summary_name.bachelor"
        ],
        "original_question": "Who is enrolled in a Bachelor degree program? List the first name, middle name, last name.",
        "question": "Who is enrolled in a Undergraduate degree program? List the first name, middle name, last name.",
        "original_SQL": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'",
        "changes_information": {
            "original_value": "Bachelor",
            "synonym": "Undergraduate"
        }
    },
    {
        "SQL": "SELECT STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob), forename , surname FROM drivers WHERE nationality = 'Argentine' ORDER BY dob DESC LIMIT 1",
        "tables": [
            "drivers"
        ],
        "columns": [
            "drivers.surname",
            "drivers.dob",
            "drivers.forename",
            "drivers.nationality"
        ],
        "values": [
            {
                "table": "drivers",
                "column": "nationality",
                "value": "Argentine",
                "condition": "="
            }
        ],
        "db_id": "formula_1",
        "source": "bird_dev",
        "evidence": "date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa; Japanese refers to nationality = 'Japanese'; age = YEAR(CURRENT_TIMESTAMP) - YEAR(dob);",
        "values_list": [
            "drivers.nationality.argentine"
        ],
        "original_question": "How old is the youngest Japanese driver? What is his name?",
        "question": "How old is the youngest Argentinian driver? What is his name?",
        "original_SQL": "SELECT STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob), forename , surname FROM drivers WHERE nationality = 'Japanese' ORDER BY dob DESC LIMIT 1",
        "changes_information": {
            "original_value": "Argentine",
            "synonym": "Argentinian"
        }
    },
    {
        "SQL": "SELECT surname FROM drivers WHERE nationality = 'Argentine'",
        "tables": [
            "drivers"
        ],
        "columns": [
            "drivers.surname",
            "drivers.nationality"
        ],
        "values": [
            {
                "table": "drivers",
                "column": "nationality",
                "value": "Argentine",
                "condition": "="
            }
        ],
        "db_id": "formula_1",
        "source": "bird_dev",
        "evidence": "Italian refers to nationality = 'italian'",
        "values_list": [
            "drivers.nationality.argentine"
        ],
        "original_question": "Please list the surnames of all the Italian drivers.",
        "question": "Please list the surnames of all the Argentinian drivers.",
        "original_SQL": "SELECT surname FROM drivers WHERE nationality = 'Italian'",
        "changes_information": {
            "original_value": "Argentine",
            "synonym": "Argentinian"
        }
    },
    {
        "SQL": "SELECT driverRef FROM drivers WHERE nationality = 'Argentine' ORDER BY JULIANDAY(dob) ASC LIMIT 1",
        "tables": [
            "drivers"
        ],
        "columns": [
            "drivers.driverref",
            "drivers.dob",
            "drivers.nationality"
        ],
        "values": [
            {
                "table": "drivers",
                "column": "nationality",
                "value": "Argentine",
                "condition": "="
            }
        ],
        "db_id": "formula_1",
        "source": "bird_dev",
        "evidence": "oldest refers to MIN(year(dob)); reference names appear in drverRef.",
        "values_list": [
            "drivers.nationality.argentine"
        ],
        "original_question": "Please state the reference name of the oldest German driver.",
        "question": "Please state the reference name of the oldest Argentinian driver.",
        "original_SQL": "SELECT driverRef FROM drivers WHERE nationality = 'German' ORDER BY JULIANDAY(dob) ASC LIMIT 1",
        "changes_information": {
            "original_value": "Argentine",
            "synonym": "Argentinian"
        }
    },
    {
        "SQL": "SELECT forename, surname, url, dob FROM drivers WHERE nationality = 'Argentine' AND STRFTIME('%Y', dob) BETWEEN '1971' AND '1985' ORDER BY dob DESC",
        "tables": [
            "drivers"
        ],
        "columns": [
            "drivers.surname",
            "drivers.forename",
            "drivers.nationality",
            "drivers.url",
            "drivers.dob"
        ],
        "values": [
            {
                "table": "drivers",
                "column": "nationality",
                "value": "Argentine",
                "condition": "="
            }
        ],
        "db_id": "formula_1",
        "source": "bird_dev",
        "evidence": "FFull name refers to forname+surname; Nationality refers to German; Date of birth refers to dob; year(dob) BETWEEN '1971' AND '1985'",
        "values_list": [
            "drivers.nationality.argentine"
        ],
        "original_question": "Find the full name, Wiki Pedia page link, and date of birth of German drivers born between 1971 and 1985. List it in descending order of date of birth.",
        "question": "Find the full name, Wiki Pedia page link, and date of birth of Argentinian drivers born between 1971 and 1985. List it in descending order of date of birth.",
        "original_SQL": "SELECT forename, surname, url, dob FROM drivers WHERE nationality = 'German' AND STRFTIME('%Y', dob) BETWEEN '1971' AND '1985' ORDER BY dob DESC",
        "changes_information": {
            "original_value": "Argentine",
            "synonym": "Argentinian"
        }
    },
    {
        "SQL": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'Registration'",
        "tables": [
            "member",
            "event",
            "attendance"
        ],
        "columns": [
            "attendance.link_to_event",
            "event.event_name",
            "member.member_id",
            "member.first_name",
            "attendance.link_to_member",
            "event.event_id",
            "member.last_name"
        ],
        "values": [
            {
                "table": "event",
                "column": "event_name",
                "value": "Registration",
                "condition": "="
            }
        ],
        "db_id": "student_club",
        "source": "bird_dev",
        "evidence": "full name of members refers to first_name, last_name; 'Laugh Out Loud' is an event name;",
        "values_list": [
            "event.event_name.laugh out loud"
        ],
        "original_question": "List the full name of all the members of the Student_Club who attended the \"Laugh Out Loud\" event.",
        "question": "List the full name of all the members of the Student_Club who attended the \"Enrollment\" event.",
        "original_SQL": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'Laugh Out Loud'",
        "changes_information": {
            "original_value": "Registration",
            "synonym": "Enrollment"
        }
    },
    {
        "SQL": "SELECT location FROM event WHERE event_name = 'Registration'",
        "tables": [
            "event"
        ],
        "columns": [
            "event.location",
            "event.event_name"
        ],
        "values": [
            {
                "table": "event",
                "column": "event_name",
                "value": "Registration",
                "condition": "="
            }
        ],
        "db_id": "student_club",
        "source": "bird_dev",
        "evidence": "'Spring Budget Review' is an event name;",
        "values_list": [
            "event.event_name.spring budget review"
        ],
        "original_question": "Give the location for \"Spring Budget Review\".",
        "question": "Give the location for \"Enrollment\".",
        "original_SQL": "SELECT location FROM event WHERE event_name = 'Spring Budget Review'",
        "changes_information": {
            "original_value": "Registration",
            "synonym": "Enrollment"
        }
    },
    {
        "SQL": "SELECT DISTINCT T3.member_id FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'Registration'",
        "tables": [
            "member",
            "event",
            "attendance"
        ],
        "columns": [
            "attendance.link_to_event",
            "event.event_name",
            "member.member_id",
            "attendance.link_to_member",
            "event.event_id"
        ],
        "values": [
            {
                "table": "event",
                "column": "event_name",
                "value": "Registration",
                "condition": "="
            }
        ],
        "db_id": "student_club",
        "source": "bird_dev",
        "evidence": "'October Meeting' is an event name;",
        "values_list": [
            "event.event_name.october meeting"
        ],
        "original_question": "List all the members who attended the event \"October Meeting\".",
        "question": "List all the members who attended the event \"Enrollment\".",
        "original_SQL": "SELECT DISTINCT T3.member_id FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'October Meeting'",
        "changes_information": {
            "original_value": "Registration",
            "synonym": "Enrollment"
        }
    },
    {
        "SQL": "SELECT T2.first_name, T2.last_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member INNER JOIN event AS T4 ON T3.link_to_event = T4.event_id WHERE T4.event_name = 'Registration' AND T1.major_name = 'Interior Design'",
        "tables": [
            "member",
            "event",
            "major",
            "attendance"
        ],
        "columns": [
            "attendance.link_to_event",
            "event.event_name",
            "member.member_id",
            "member.link_to_major",
            "member.first_name",
            "attendance.link_to_member",
            "major.major_id",
            "major.major_name",
            "event.event_id",
            "member.last_name"
        ],
        "values": [
            {
                "table": "event",
                "column": "event_name",
                "value": "Registration",
                "condition": "="
            },
            {
                "table": "major",
                "column": "major_name",
                "value": "Interior Design",
                "condition": "="
            }
        ],
        "db_id": "student_club",
        "source": "bird_dev",
        "evidence": "majored in music refers to major_name = 'Interior Design'; 'Community Theater' is the event name;",
        "values_list": [
            "event.event_name.community theater",
            "major.major_name.interior design"
        ],
        "original_question": "Among the students majored in interior design, who have attended the Community Theater event?",
        "question": "Among the students majored in interior design, who have attended the Enrollment event?",
        "original_SQL": "SELECT T2.first_name, T2.last_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member INNER JOIN event AS T4 ON T3.link_to_event = T4.event_id WHERE T4.event_name = 'Community Theater' AND T1.major_name = 'Interior Design'",
        "changes_information": {
            "original_value": "Registration",
            "synonym": "Enrollment"
        }
    },
    {
        "SQL": "SELECT T4.first_name, T4.last_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget INNER JOIN member AS T4 ON T3.link_to_member = T4.member_id WHERE T1.event_name = 'Registration'",
        "tables": [
            "budget",
            "event",
            "member",
            "expense"
        ],
        "columns": [
            "expense.link_to_member",
            "event.event_name",
            "member.member_id",
            "member.first_name",
            "budget.link_to_event",
            "budget.budget_id",
            "expense.link_to_budget",
            "event.event_id",
            "member.last_name"
        ],
        "values": [
            {
                "table": "event",
                "column": "event_name",
                "value": "Registration",
                "condition": "="
            }
        ],
        "db_id": "student_club",
        "source": "bird_dev",
        "evidence": "name of students means the full name; full name refers to first_name, last_name;'Yearly Kickoff' is an event name;",
        "values_list": [
            "event.event_name.yearly kickoff"
        ],
        "original_question": "Which student has been entrusted to manage the budget for the Yearly Kickoff?",
        "question": "Which student has been entrusted to manage the budget for the Enrollment?",
        "original_SQL": "SELECT T4.first_name, T4.last_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget INNER JOIN member AS T4 ON T3.link_to_member = T4.member_id WHERE T1.event_name = 'Yearly Kickoff'",
        "changes_information": {
            "original_value": "Registration",
            "synonym": "Enrollment"
        }
    },
    {
        "SQL": "SELECT T2.category, SUM(T2.amount) FROM event AS T1 JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'Registration' GROUP BY T2.category ORDER BY SUM(T2.amount) ASC",
        "tables": [
            "budget",
            "event"
        ],
        "columns": [
            "budget.amount",
            "event.event_name",
            "budget.category",
            "budget.link_to_event",
            "event.event_id"
        ],
        "values": [
            {
                "table": "event",
                "column": "event_name",
                "value": "Registration",
                "condition": "="
            }
        ],
        "db_id": "student_club",
        "source": "bird_dev",
        "evidence": "'April Speaker' is an event name; amount budgeted refers to SUM(amount); budget categories refers to category",
        "values_list": [
            "event.event_name.april speaker"
        ],
        "original_question": "Calculate the amount budgeted for 'April Speaker' event. List all the budgeted categories for said event in an ascending order based on their amount budgeted.",
        "question": "Calculate the amount budgeted for 'Enrollment' event. List all the budgeted categories for said event in an ascending order based on their amount budgeted.",
        "original_SQL": "SELECT T2.category, SUM(T2.amount) FROM event AS T1 JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'April Speaker' GROUP BY T2.category ORDER BY SUM(T2.amount) ASC",
        "changes_information": {
            "original_value": "Registration",
            "synonym": "Enrollment"
        }
    },
    {
        "SQL": "SELECT T2.category, T2.amount FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'Registration'",
        "tables": [
            "budget",
            "event"
        ],
        "columns": [
            "budget.amount",
            "event.event_name",
            "budget.category",
            "budget.link_to_event",
            "event.event_id"
        ],
        "values": [
            {
                "table": "event",
                "column": "event_name",
                "value": "Registration",
                "condition": "="
            }
        ],
        "db_id": "student_club",
        "source": "bird_dev",
        "evidence": "amount budgeted refers to amount, 'January Speaker' is the event name;",
        "values_list": [
            "event.event_name.january speaker"
        ],
        "original_question": "What category was budgeted for the 'January Speaker' event and how much was the amount budgeted for that category?",
        "question": "What category was budgeted for the 'Enrollment' event and how much was the amount budgeted for that category?",
        "original_SQL": "SELECT T2.category, T2.amount FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'January Speaker'",
        "changes_information": {
            "original_value": "Registration",
            "synonym": "Enrollment"
        }
    },
    {
        "SQL": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.status = 'Planning' ORDER BY T1.spent / T1.amount DESC LIMIT 1",
        "tables": [
            "budget",
            "event"
        ],
        "columns": [
            "event.event_name",
            "budget.amount",
            "budget.link_to_event",
            "event.status",
            "event.event_id",
            "budget.spent"
        ],
        "values": [
            {
                "table": "event",
                "column": "status",
                "value": "Planning",
                "condition": "="
            }
        ],
        "db_id": "student_club",
        "source": "bird_dev",
        "evidence": "closed events refers to event_name where status = 'Closed'; highest spend-to budget ratio refers to MAX(DIVIDE(spent, amount))",
        "values_list": [
            "event.status.planning"
        ],
        "original_question": "Among all the closed events, which event has the highest spend-to-budget ratio?",
        "question": "Among all the Organizing events, which event has the highest spend-to-budget ratio?",
        "original_SQL": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.status = 'Closed' ORDER BY T1.spent / T1.amount DESC LIMIT 1",
        "changes_information": {
            "original_value": "Planning",
            "synonym": "Organizing"
        }
    },
    {
        "SQL": "SELECT DISTINCT event_name FROM event WHERE type = 'Game' AND date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-03-15' AND '2020-03-20' AND status = 'Planning'",
        "tables": [
            "event"
        ],
        "columns": [
            "event.type",
            "event.event_name",
            "event.event_date",
            "event.status"
        ],
        "values": [
            {
                "table": "event",
                "column": "status",
                "value": "Planning",
                "condition": "="
            },
            {
                "table": "event",
                "column": "type",
                "value": "Game",
                "condition": "="
            }
        ],
        "db_id": "student_club",
        "source": "bird_dev",
        "evidence": "name of events refers event_name; game event that was closed refers to type = 'Game' where status = 'Closed'; event_date BETWEEN '2019-03-15' and '2020-03-20'; ",
        "values_list": [
            "event.status.planning",
            "event.type.game"
        ],
        "original_question": "List the names of closed event as \"game\" that was closed from 3/15/2019 to 3/20/2020.",
        "question": "List the names of Organizing event as \"game\" that was closed from 3/15/2019 to 3/20/2020.",
        "original_SQL": "SELECT DISTINCT event_name FROM event WHERE type = 'Game' AND date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-03-15' AND '2020-03-20' AND status = 'Closed'",
        "changes_information": {
            "original_value": "Planning",
            "synonym": "Organizing"
        }
    },
    {
        "SQL": "SELECT DISTINCT event_name FROM event WHERE type = 'Registration' AND date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-03-15' AND '2020-03-20' AND status = 'Closed'",
        "tables": [
            "event"
        ],
        "columns": [
            "event.type",
            "event.event_name",
            "event.event_date",
            "event.status"
        ],
        "values": [
            {
                "table": "event",
                "column": "status",
                "value": "Closed",
                "condition": "="
            },
            {
                "table": "event",
                "column": "type",
                "value": "Registration",
                "condition": "="
            }
        ],
        "db_id": "student_club",
        "source": "bird_dev",
        "evidence": "name of events refers event_name; game event that was closed refers to type = 'Game' where status = 'Closed'; event_date BETWEEN '2019-03-15' and '2020-03-20'; ",
        "values_list": [
            "event.status.closed",
            "event.type.registration"
        ],
        "original_question": "List the names of closed event as \"game\" that was closed from 3/15/2019 to 3/20/2020.",
        "question": "List the names of closed event as \"Sign-up\" that was closed from 3/15/2019 to 3/20/2020.",
        "original_SQL": "SELECT DISTINCT event_name FROM event WHERE type = 'Game' AND date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-03-15' AND '2020-03-20' AND status = 'Closed'",
        "changes_information": {
            "original_value": "Registration",
            "synonym": "Sign-up"
        }
    },
    {
        "SQL": "SELECT Symptoms FROM Examination WHERE Diagnosis = 'Normal' GROUP BY Symptoms ORDER BY COUNT(Symptoms) DESC LIMIT 1",
        "tables": [
            "examination"
        ],
        "columns": [
            "examination.symptoms",
            "examination.diagnosis"
        ],
        "values": [
            {
                "table": "examination",
                "column": "diagnosis",
                "value": "Normal",
                "condition": "="
            }
        ],
        "db_id": "thrombosis_prediction",
        "source": "bird_dev",
        "evidence": "the most common sign refers to MAX(symptoms); 'SLE' refers to diagnosis",
        "values_list": [
            "examination.diagnosis.normal"
        ],
        "original_question": "What is the most common sign of patients with SLE disease?",
        "question": "What is the most common sign of patients with regular disease?",
        "original_SQL": "SELECT Symptoms FROM Examination WHERE Diagnosis = 'SLE' GROUP BY Symptoms ORDER BY COUNT(Symptoms) DESC LIMIT 1",
        "changes_information": {
            "original_value": "Normal",
            "synonym": "regular"
        }
    },
    {
        "SQL": "SELECT T3.cost FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'September Speaker' AND T3.expense_description = 'Parking'",
        "tables": [
            "budget",
            "event",
            "expense"
        ],
        "columns": [
            "event.event_name",
            "expense.cost",
            "budget.budget_id",
            "budget.link_to_event",
            "expense.link_to_budget",
            "event.event_id",
            "expense.expense_description"
        ],
        "values": [
            {
                "table": "event",
                "column": "event_name",
                "value": "September Speaker",
                "condition": "="
            },
            {
                "table": "expense",
                "column": "expense_description",
                "value": "Parking",
                "condition": "="
            }
        ],
        "db_id": "student_club",
        "source": "bird_dev",
        "evidence": "'Posters' is the expense description; 'September Speaker' is an event name",
        "values_list": [
            "event.event_name.september speaker",
            "expense.expense_description.parking"
        ],
        "original_question": "Indicate the cost of posters for 'September Speaker' event.",
        "question": "Indicate the cost of vehicle storage for 'September Speaker' event.",
        "original_SQL": "SELECT T3.cost FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'September Speaker' AND T3.expense_description = 'Posters'",
        "changes_information": {
            "original_value": "Parking",
            "synonym": "vehicle storage"
        }
    },
    {
        "SQL": "SELECT DISTINCT T2.category FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE T1.expense_description = 'Parking'",
        "tables": [
            "budget",
            "expense"
        ],
        "columns": [
            "budget.budget_id",
            "expense.link_to_budget",
            "budget.category",
            "expense.expense_description"
        ],
        "values": [
            {
                "table": "expense",
                "column": "expense_description",
                "value": "Parking",
                "condition": "="
            }
        ],
        "db_id": "student_club",
        "source": "bird_dev",
        "evidence": "'Posters' refers to expense description",
        "values_list": [
            "expense.expense_description.parking"
        ],
        "original_question": "Which budget category does the expense 'Posters' fall to?",
        "question": "Which budget category does the expense 'vehicle storage' fall to?",
        "original_SQL": "SELECT DISTINCT T2.category FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE T1.expense_description = 'Posters'",
        "changes_information": {
            "original_value": "Parking",
            "synonym": "vehicle storage"
        }
    },
    {
        "SQL": "SELECT feature_description FROM Features WHERE feature_name  =  'rooftop';",
        "tables": [
            "features"
        ],
        "columns": [
            "features.feature_name",
            "features.feature_description"
        ],
        "values": [
            {
                "table": "features",
                "column": "feature_name",
                "value": "rooftop",
                "condition": "="
            }
        ],
        "db_id": "real_estate_rentals",
        "source": "spider_test",
        "evidence": "",
        "values_list": [
            "features.feature_name.rooftop"
        ],
        "original_question": "How is the feature rooftop described?",
        "question": "How is the feature roof terrace described?",
        "original_SQL": "SELECT feature_description FROM Features WHERE feature_name  =  'rooftop';",
        "changes_information": {
            "original_value": "rooftop",
            "synonym": "roof terrace"
        }
    },
    {
        "SQL": "SELECT feature_description FROM Features WHERE feature_name  =  'rooftop';",
        "tables": [
            "features"
        ],
        "columns": [
            "features.feature_name",
            "features.feature_description"
        ],
        "values": [
            {
                "table": "features",
                "column": "feature_name",
                "value": "rooftop",
                "condition": "="
            }
        ],
        "db_id": "real_estate_rentals",
        "source": "spider_test",
        "evidence": "",
        "values_list": [
            "features.feature_name.rooftop"
        ],
        "original_question": "Return the description of the feature 'rooftop'.",
        "question": "Return the description of the feature 'roof terrace'.",
        "original_SQL": "SELECT feature_description FROM Features WHERE feature_name  =  'rooftop';",
        "changes_information": {
            "original_value": "rooftop",
            "synonym": "roof terrace"
        }
    },
    {
        "SQL": "SELECT T2.town_city FROM Properties AS T1 JOIN Addresses AS T2 ON T1.property_address_id  =  T2.address_id JOIN Property_Features AS T3 ON T1.property_id  =  T3.property_id JOIN Features AS T4 ON T4.feature_id  =  T3.feature_id WHERE T4.feature_name  =  'rooftop';",
        "tables": [
            "property_features",
            "properties",
            "features",
            "addresses"
        ],
        "columns": [
            "features.feature_id",
            "addresses.address_id",
            "features.feature_name",
            "property_features.feature_id",
            "addresses.town_city",
            "property_features.property_id",
            "properties.property_address_id",
            "properties.property_id"
        ],
        "values": [
            {
                "table": "features",
                "column": "feature_name",
                "value": "rooftop",
                "condition": "="
            }
        ],
        "db_id": "real_estate_rentals",
        "source": "spider_test",
        "evidence": "",
        "values_list": [
            "features.feature_name.swimming pool"
        ],
        "original_question": "In which cities are there any properties equipped with a swimming pool?",
        "question": "In which cities are there any properties equipped with a roof terrace?",
        "original_SQL": "SELECT T2.town_city FROM Properties AS T1 JOIN Addresses AS T2 ON T1.property_address_id  =  T2.address_id JOIN Property_Features AS T3 ON T1.property_id  =  T3.property_id JOIN Features AS T4 ON T4.feature_id  =  T3.feature_id WHERE T4.feature_name  =  'swimming pool';",
        "changes_information": {
            "original_value": "rooftop",
            "synonym": "roof terrace"
        }
    },
    {
        "SQL": "SELECT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'German'",
        "tables": [
            "cards",
            "foreign_data"
        ],
        "columns": [
            "cards.uuid",
            "cards.name",
            "foreign_data.language",
            "foreign_data.uuid"
        ],
        "values": [
            {
                "table": "foreign_data",
                "column": "language",
                "value": "German",
                "condition": "="
            }
        ],
        "db_id": "card_games",
        "source": "bird_dev",
        "evidence": "Japanese' is the language;",
        "values_list": [
            "foreign_data.language.german"
        ],
        "original_question": "Name all the cards which have alternative language in Japanese.",
        "question": "Name all the cards which have alternative language in Deutsch.",
        "original_SQL": "SELECT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Japanese'",
        "changes_information": {
            "original_value": "German",
            "synonym": "Deutsch"
        }
    },
    {
        "SQL": "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'German'",
        "tables": [
            "cards",
            "foreign_data"
        ],
        "columns": [
            "cards.artist",
            "foreign_data.language",
            "foreign_data.uuid",
            "cards.uuid"
        ],
        "values": [
            {
                "table": "foreign_data",
                "column": "language",
                "value": "German",
                "condition": "="
            }
        ],
        "db_id": "card_games",
        "source": "bird_dev",
        "evidence": "Phyrexian' is the language; name of artists refers to artist;",
        "values_list": [
            "foreign_data.language.german"
        ],
        "original_question": "Please provide the names of the artists who illustrated the card art in Phyrexian.",
        "question": "Please provide the names of the artists who illustrated the card art in Deutsch.",
        "original_SQL": "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Phyrexian'",
        "changes_information": {
            "original_value": "German",
            "synonym": "Deutsch"
        }
    },
    {
        "SQL": "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'German'",
        "tables": [
            "cards",
            "foreign_data"
        ],
        "columns": [
            "cards.artist",
            "foreign_data.language",
            "foreign_data.uuid",
            "cards.uuid"
        ],
        "values": [
            {
                "table": "foreign_data",
                "column": "language",
                "value": "German",
                "condition": "="
            }
        ],
        "db_id": "card_games",
        "source": "bird_dev",
        "evidence": "Chinese Simplified' is the language;",
        "values_list": [
            "foreign_data.language.chinese simplified"
        ],
        "original_question": "List down the name of artists for cards in Chinese Simplified.",
        "question": "List down the name of artists for cards in Deutsch.",
        "original_SQL": "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Chinese Simplified'",
        "changes_information": {
            "original_value": "German",
            "synonym": "Deutsch"
        }
    },
    {
        "SQL": "SELECT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.availability = 'paper' AND T2.language = 'German'",
        "tables": [
            "cards",
            "foreign_data"
        ],
        "columns": [
            "cards.name",
            "foreign_data.uuid",
            "cards.uuid",
            "foreign_data.language",
            "cards.availability"
        ],
        "values": [
            {
                "table": "cards",
                "column": "availability",
                "value": "paper",
                "condition": "="
            },
            {
                "table": "foreign_data",
                "column": "language",
                "value": "German",
                "condition": "="
            }
        ],
        "db_id": "card_games",
        "source": "bird_dev",
        "evidence": "available in paper refers to availability = 'paper'; 'Japanese is the language;",
        "values_list": [
            "cards.availability.paper",
            "foreign_data.language.german"
        ],
        "original_question": "What are the cards that only available in paper and Japanese language?",
        "question": "What are the cards that only available in paper and Deutsch language?",
        "original_SQL": "SELECT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.availability = 'paper' AND T2.language = 'Japanese'",
        "changes_information": {
            "original_value": "German",
            "synonym": "Deutsch"
        }
    },
    {
        "SQL": "SELECT ( SELECT CAST(SUM(CASE WHEN language = 'German' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM foreign_data ), name FROM foreign_data WHERE language = 'German'",
        "tables": [
            "foreign_data"
        ],
        "columns": [
            "foreign_data.language"
        ],
        "values": [
            {
                "table": "foreign_data",
                "column": "language",
                "value": "German",
                "condition": "="
            },
            {
                "table": "",
                "column": "language",
                "value": "Spanish",
                "condition": "="
            },
            {
                "table": "",
                "column": "language",
                "value": "Spanish",
                "condition": "="
            }
        ],
        "db_id": "card_games",
        "source": "bird_dev",
        "evidence": "Spanish refer to language; Percentage refer to DIVIDE(SUM(ID where language = 'Spanish'), COUNT(id))*100",
        "values_list": [
            "foreign_data.language.german",
            ".language.spanish",
            ".language.spanish"
        ],
        "original_question": "Calculate the percentage of cards in Spanish. List them by name.",
        "question": "Calculate the percentage of cards in Deutsch. List them by name.",
        "original_SQL": "SELECT ( SELECT CAST(SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM foreign_data ), name FROM foreign_data WHERE language = 'Spanish'",
        "changes_information": {
            "original_value": "German",
            "synonym": "Deutsch"
        }
    },
    {
        "SQL": "SELECT T1.subtypes, T1.supertypes FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'German' AND T1.subtypes IS NOT NULL AND T1.supertypes IS NOT NULL",
        "tables": [
            "cards",
            "foreign_data"
        ],
        "columns": [
            "cards.subtypes",
            "foreign_data.uuid",
            "cards.supertypes",
            "cards.uuid",
            "foreign_data.language"
        ],
        "values": [
            {
                "table": "foreign_data",
                "column": "language",
                "value": "German",
                "condition": "="
            }
        ],
        "db_id": "card_games",
        "source": "bird_dev",
        "evidence": "German refer to language; all types refer to the subtypes, supertypes; subtypes is not null AND supertypes is not null",
        "values_list": [
            "foreign_data.language.german"
        ],
        "original_question": "Lists all types of cards in German.",
        "question": "Lists all types of cards in Deutsch.",
        "original_SQL": "SELECT T1.subtypes, T1.supertypes FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'German' AND T1.subtypes IS NOT NULL AND T1.supertypes IS NOT NULL",
        "changes_information": {
            "original_value": "German",
            "synonym": "Deutsch"
        }
    },
    {
        "SQL": "SELECT DISTINCT T1.text FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid INNER JOIN sets AS T3 ON T3.code = T2.setCode WHERE T3.name = 'Coldsnap' AND T1.language = 'German'",
        "tables": [
            "sets",
            "cards",
            "foreign_data"
        ],
        "columns": [
            "sets.code",
            "foreign_data.text",
            "foreign_data.uuid",
            "cards.uuid",
            "foreign_data.language",
            "cards.setcode",
            "sets.name"
        ],
        "values": [
            {
                "table": "sets",
                "column": "name",
                "value": "Coldsnap",
                "condition": "="
            },
            {
                "table": "foreign_data",
                "column": "language",
                "value": "German",
                "condition": "="
            }
        ],
        "db_id": "card_games",
        "source": "bird_dev",
        "evidence": "card set Coldsnap refers to name = 'Coldsnap'; Italian refers to language = 'Italian'",
        "values_list": [
            "sets.name.coldsnap",
            "foreign_data.language.german"
        ],
        "original_question": "Please list the Italian text ruling of all the cards in the set Coldsnap.",
        "question": "Please list the Deutsch text ruling of all the cards in the set Coldsnap.",
        "original_SQL": "SELECT DISTINCT T1.text FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid INNER JOIN sets AS T3 ON T3.code = T2.setCode WHERE T3.name = 'Coldsnap' AND T1.language = 'Italian'",
        "changes_information": {
            "original_value": "German",
            "synonym": "Deutsch"
        }
    },
    {
        "SQL": "SELECT T2.name FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid INNER JOIN sets AS T3 ON T3.code = T2.setCode WHERE T3.name = 'Coldsnap' AND T1.language = 'German' ORDER BY T2.convertedManaCost DESC",
        "tables": [
            "sets",
            "cards",
            "foreign_data"
        ],
        "columns": [
            "sets.code",
            "cards.convertedmanacost",
            "cards.name",
            "foreign_data.uuid",
            "cards.uuid",
            "foreign_data.language",
            "cards.setcode",
            "sets.name"
        ],
        "values": [
            {
                "table": "sets",
                "column": "name",
                "value": "Coldsnap",
                "condition": "="
            },
            {
                "table": "foreign_data",
                "column": "language",
                "value": "German",
                "condition": "="
            }
        ],
        "db_id": "card_games",
        "source": "bird_dev",
        "evidence": "card set Coldsnap refers to name = 'Coldsnap'; Italian refers to language = 'Italian'; highest converted mana cost refers to MAX(convertedManaCost)",
        "values_list": [
            "sets.name.coldsnap",
            "foreign_data.language.german"
        ],
        "original_question": "Please list the Italian names of the cards in the set Coldsnap with the highest converted mana cost.",
        "question": "Please list the Deutsch names of the cards in the set Coldsnap with the highest converted mana cost.",
        "original_SQL": "SELECT T2.name FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid INNER JOIN sets AS T3 ON T3.code = T2.setCode WHERE T3.name = 'Coldsnap' AND T1.language = 'Italian' ORDER BY T2.convertedManaCost DESC",
        "changes_information": {
            "original_value": "German",
            "synonym": "Deutsch"
        }
    },
    {
        "SQL": "SELECT T1.payment_id ,  T1.payment_details FROM Payments AS T1 JOIN Invoices AS T2 ON T1.invoice_id  =  T2.invoice_id WHERE T2.invoice_status  =  'Starting'",
        "tables": [
            "payments",
            "invoices"
        ],
        "columns": [
            "payments.payment_id",
            "payments.invoice_id",
            "payments.payment_details",
            "invoices.invoice_id",
            "invoices.invoice_status"
        ],
        "values": [
            {
                "table": "invoices",
                "column": "invoice_status",
                "value": "Starting",
                "condition": "="
            }
        ],
        "db_id": "advertising_agencies",
        "source": "spider_test",
        "evidence": "",
        "values_list": [
            "invoices.invoice_status.starting"
        ],
        "original_question": "Show all payment ids and details for invoices whose status is 'Working'.",
        "question": "Show all payment ids and details for invoices whose status is 'Beginning'.",
        "original_SQL": "SELECT T1.payment_id ,  T1.payment_details FROM Payments AS T1 JOIN Invoices AS T2 ON T1.invoice_id  =  T2.invoice_id WHERE T2.invoice_status  =  'Working'",
        "changes_information": {
            "original_value": "Starting",
            "synonym": "Beginning"
        }
    },
    {
        "SQL": "SELECT T1.payment_id ,  T1.payment_details FROM Payments AS T1 JOIN Invoices AS T2 ON T1.invoice_id  =  T2.invoice_id WHERE T2.invoice_status  =  'Starting'",
        "tables": [
            "payments",
            "invoices"
        ],
        "columns": [
            "payments.payment_id",
            "payments.invoice_id",
            "payments.payment_details",
            "invoices.invoice_id",
            "invoices.invoice_status"
        ],
        "values": [
            {
                "table": "invoices",
                "column": "invoice_status",
                "value": "Starting",
                "condition": "="
            }
        ],
        "db_id": "advertising_agencies",
        "source": "spider_test",
        "evidence": "",
        "values_list": [
            "invoices.invoice_status.starting"
        ],
        "original_question": "What are all payment ids and payment details for invoices with status Working?",
        "question": "What are all payment ids and payment details for invoices with status Beginning?",
        "original_SQL": "SELECT T1.payment_id ,  T1.payment_details FROM Payments AS T1 JOIN Invoices AS T2 ON T1.invoice_id  =  T2.invoice_id WHERE T2.invoice_status  =  'Working'",
        "changes_information": {
            "original_value": "Starting",
            "synonym": "Beginning"
        }
    },
    {
        "SQL": "SELECT T1.payment_id ,  T1.payment_details FROM Payments AS T1 JOIN Invoices AS T2 ON T1.invoice_id  =  T2.invoice_id WHERE T2.invoice_status  =  'Finish'",
        "tables": [
            "payments",
            "invoices"
        ],
        "columns": [
            "payments.payment_id",
            "payments.invoice_id",
            "payments.payment_details",
            "invoices.invoice_id",
            "invoices.invoice_status"
        ],
        "values": [
            {
                "table": "invoices",
                "column": "invoice_status",
                "value": "Finish",
                "condition": "="
            }
        ],
        "db_id": "advertising_agencies",
        "source": "spider_test",
        "evidence": "",
        "values_list": [
            "invoices.invoice_status.finish"
        ],
        "original_question": "Show all payment ids and details for invoices whose status is 'Working'.",
        "question": "Show all payment ids and details for invoices whose status is 'Complete'.",
        "original_SQL": "SELECT T1.payment_id ,  T1.payment_details FROM Payments AS T1 JOIN Invoices AS T2 ON T1.invoice_id  =  T2.invoice_id WHERE T2.invoice_status  =  'Working'",
        "changes_information": {
            "original_value": "Finish",
            "synonym": "Complete"
        }
    },
    {
        "SQL": "SELECT T1.payment_id ,  T1.payment_details FROM Payments AS T1 JOIN Invoices AS T2 ON T1.invoice_id  =  T2.invoice_id WHERE T2.invoice_status  =  'Finish'",
        "tables": [
            "payments",
            "invoices"
        ],
        "columns": [
            "payments.payment_id",
            "payments.invoice_id",
            "payments.payment_details",
            "invoices.invoice_id",
            "invoices.invoice_status"
        ],
        "values": [
            {
                "table": "invoices",
                "column": "invoice_status",
                "value": "Finish",
                "condition": "="
            }
        ],
        "db_id": "advertising_agencies",
        "source": "spider_test",
        "evidence": "",
        "values_list": [
            "invoices.invoice_status.finish"
        ],
        "original_question": "What are all payment ids and payment details for invoices with status Working?",
        "question": "What are all payment ids and payment details for invoices with status Complete?",
        "original_SQL": "SELECT T1.payment_id ,  T1.payment_details FROM Payments AS T1 JOIN Invoices AS T2 ON T1.invoice_id  =  T2.invoice_id WHERE T2.invoice_status  =  'Working'",
        "changes_information": {
            "original_value": "Finish",
            "synonym": "Complete"
        }
    },
    {
        "SQL": "SELECT DISTINCT T1.id FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'modern' AND T2.status = 'Banned' AND T1.rarity = 'mythic'",
        "tables": [
            "cards",
            "legalities"
        ],
        "columns": [
            "cards.rarity",
            "legalities.format",
            "cards.id",
            "legalities.status",
            "legalities.uuid",
            "cards.uuid"
        ],
        "values": [
            {
                "table": "cards",
                "column": "rarity",
                "value": "mythic",
                "condition": "="
            },
            {
                "table": "legalities",
                "column": "format",
                "value": "modern",
                "condition": "="
            },
            {
                "table": "legalities",
                "column": "status",
                "value": "Banned",
                "condition": "="
            }
        ],
        "db_id": "card_games",
        "source": "bird_dev",
        "evidence": "mythic rarity printing refers to rarity = 'mythic'; card banned refers to status = 'Banned'; in gladiator format refers to format = 'gladiator';",
        "values_list": [
            "cards.rarity.mythic",
            "legalities.format.modern",
            "legalities.status.banned"
        ],
        "original_question": "List all the mythic rarity print cards banned in gladiator format.",
        "question": "List all the mythic rarity print cards banned in contemporary format.",
        "original_SQL": "SELECT DISTINCT T1.id FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'gladiator' AND T2.status = 'Banned' AND T1.rarity = 'mythic'",
        "changes_information": {
            "original_value": "modern",
            "synonym": "contemporary"
        }
    },
    {
        "SQL": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.type = 'Artifact' AND T2.format = 'modern' AND T1.side IS NULL",
        "tables": [
            "cards",
            "legalities"
        ],
        "columns": [
            "cards.side",
            "legalities.format",
            "legalities.status",
            "legalities.uuid",
            "cards.uuid",
            "cards.type"
        ],
        "values": [
            {
                "table": "cards",
                "column": "type",
                "value": "Artifact",
                "condition": "="
            },
            {
                "table": "legalities",
                "column": "format",
                "value": "modern",
                "condition": "="
            }
        ],
        "db_id": "card_games",
        "source": "bird_dev",
        "evidence": "Artifact type of cards refers to types = 'Artifact'; card does not have multiple faces on the same card refers to side is NULL'; vintage play format refers to format = 'vintage';",
        "values_list": [
            "cards.type.artifact",
            "legalities.format.modern"
        ],
        "original_question": "For artifact type of cards that do not have multiple faces on the same card, state its legalities status for vintage play format.",
        "question": "For artifact type of cards that do not have multiple faces on the same card, state its legalities status for contemporary play format.",
        "original_SQL": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.type = 'Artifact' AND T2.format = 'vintage' AND T1.side IS NULL",
        "changes_information": {
            "original_value": "modern",
            "synonym": "contemporary"
        }
    },
    {
        "SQL": "SELECT T1.uuid, T3.language FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid INNER JOIN foreign_data AS T3 ON T1.uuid = T3.uuid WHERE T2.format = 'modern'",
        "tables": [
            "cards",
            "legalities",
            "foreign_data"
        ],
        "columns": [
            "legalities.format",
            "foreign_data.uuid",
            "legalities.uuid",
            "cards.uuid",
            "foreign_data.language"
        ],
        "values": [
            {
                "table": "legalities",
                "column": "format",
                "value": "modern",
                "condition": "="
            }
        ],
        "db_id": "card_games",
        "source": "bird_dev",
        "evidence": "legacy card refers to format = 'legacy'; foreign language refers to language in foreign_data",
        "values_list": [
            "legalities.format.modern"
        ],
        "original_question": "List down the uuid for legacy cards and the foreign language of these cards.",
        "question": "List down the uuid for contemporary cards and the foreign language of these cards.",
        "original_SQL": "SELECT T1.uuid, T3.language FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid INNER JOIN foreign_data AS T3 ON T1.uuid = T3.uuid WHERE T2.format = 'legacy'",
        "changes_information": {
            "original_value": "modern",
            "synonym": "contemporary"
        }
    },
    {
        "SQL": "SELECT T1.id FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Erica Yang' AND T2.format = 'modern' AND T1.availability = 'paper'",
        "tables": [
            "cards",
            "legalities"
        ],
        "columns": [
            "cards.artist",
            "legalities.format",
            "cards.id",
            "legalities.uuid",
            "cards.uuid",
            "cards.availability"
        ],
        "values": [
            {
                "table": "cards",
                "column": "availability",
                "value": "paper",
                "condition": "="
            },
            {
                "table": "cards",
                "column": "artist",
                "value": "Erica Yang",
                "condition": "="
            },
            {
                "table": "legalities",
                "column": "format",
                "value": "modern",
                "condition": "="
            }
        ],
        "db_id": "card_games",
        "source": "bird_dev",
        "evidence": "available in paper refers to availability = 'paper'",
        "values_list": [
            "cards.availability.paper",
            "cards.artist.erica yang",
            "legalities.format.modern"
        ],
        "original_question": "Is there any card from Erica Yang artist in pauper format and available in paper? If so, indicate its ID.",
        "question": "Is there any card from Erica Yang artist in contemporary format and available in paper? If so, indicate its ID.",
        "original_SQL": "SELECT T1.id FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Erica Yang' AND T2.format = 'pauper' AND T1.availability = 'paper'",
        "changes_information": {
            "original_value": "modern",
            "synonym": "contemporary"
        }
    },
    {
        "SQL": "SELECT DISTINCT T1.id FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'gladiator' AND T2.status = 'Banned' AND T1.rarity = 'mythic'",
        "tables": [
            "cards",
            "legalities"
        ],
        "columns": [
            "cards.rarity",
            "legalities.format",
            "cards.id",
            "legalities.status",
            "legalities.uuid",
            "cards.uuid"
        ],
        "values": [
            {
                "table": "cards",
                "column": "rarity",
                "value": "mythic",
                "condition": "="
            },
            {
                "table": "legalities",
                "column": "format",
                "value": "gladiator",
                "condition": "="
            },
            {
                "table": "legalities",
                "column": "status",
                "value": "Banned",
                "condition": "="
            }
        ],
        "db_id": "card_games",
        "source": "bird_dev",
        "evidence": "mythic rarity printing refers to rarity = 'mythic'; card banned refers to status = 'Banned'; in gladiator format refers to format = 'gladiator';",
        "values_list": [
            "cards.rarity.mythic",
            "legalities.format.gladiator",
            "legalities.status.banned"
        ],
        "original_question": "List all the mythic rarity print cards banned in gladiator format.",
        "question": "List all the mythic rarity print cards Prohibited in gladiator format.",
        "original_SQL": "SELECT DISTINCT T1.id FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'gladiator' AND T2.status = 'Banned' AND T1.rarity = 'mythic'",
        "changes_information": {
            "original_value": "Banned",
            "synonym": "Prohibited"
        }
    },
    {
        "SQL": "SELECT T1.id FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid INNER JOIN legalities AS T3 ON T1.uuid = T3.uuid WHERE T3.status = 'Banned' AND T1.types = 'Creature'",
        "tables": [
            "rulings",
            "cards",
            "legalities"
        ],
        "columns": [
            "cards.types",
            "cards.id",
            "legalities.status",
            "legalities.uuid",
            "cards.uuid",
            "rulings.uuid"
        ],
        "values": [
            {
                "table": "legalities",
                "column": "status",
                "value": "Banned",
                "condition": "="
            },
            {
                "table": "cards",
                "column": "types",
                "value": "Creature",
                "condition": "="
            }
        ],
        "db_id": "card_games",
        "source": "bird_dev",
        "evidence": "legal status refer to status = 'legal'; Goblin-type cards refer to types = 'Creature';",
        "values_list": [
            "legalities.status.banned",
            "cards.types.creature"
        ],
        "original_question": "Lists by ID all Creature-type cards with legal status.",
        "question": "Lists by ID all Creature-type cards with Prohibited status.",
        "original_SQL": "SELECT T1.id FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid INNER JOIN legalities AS T3 ON T1.uuid = T3.uuid WHERE T3.status = 'Legal' AND T1.types = 'Creature'",
        "changes_information": {
            "original_value": "Banned",
            "synonym": "Prohibited"
        }
    },
    {
        "SQL": "SELECT T1.originalReleaseDate, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'mythic' AND T1.originalReleaseDate IS NOT NULL AND T2.status = 'Banned' ORDER BY T1.originalReleaseDate LIMIT 1",
        "tables": [
            "cards",
            "legalities"
        ],
        "columns": [
            "cards.rarity",
            "legalities.format",
            "legalities.status",
            "cards.originalreleasedate",
            "legalities.uuid",
            "cards.uuid"
        ],
        "values": [
            {
                "table": "legalities",
                "column": "status",
                "value": "Banned",
                "condition": "="
            },
            {
                "table": "cards",
                "column": "rarity",
                "value": "mythic",
                "condition": "="
            }
        ],
        "db_id": "card_games",
        "source": "bird_dev",
        "evidence": "the oldest card refers to MIN(originalReleaseDate); mythic card refers to rarity = 'mythic'; legal play refers to status = 'legal'; play format refers to format",
        "values_list": [
            "legalities.status.banned",
            "cards.rarity.mythic"
        ],
        "original_question": "When was the oldest mythic card released and what are its legal play formats?",
        "question": "When was the oldest mythic card released and what are its Prohibited play formats?",
        "original_SQL": "SELECT T1.originalReleaseDate, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'mythic' AND T1.originalReleaseDate IS NOT NULL AND T2.status = 'Legal' ORDER BY T1.originalReleaseDate LIMIT 1",
        "changes_information": {
            "original_value": "Banned",
            "synonym": "Prohibited"
        }
    },
    {
        "SQL": "WITH MaxBanned AS (SELECT format, COUNT(*) AS count_banned FROM legalities WHERE status = 'Banned' GROUP BY format ORDER BY COUNT(*) DESC LIMIT 1) SELECT T2.format, T1.name FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid INNER JOIN MaxBanned MB ON MB.format = T2.format WHERE T2.status = 'Banned'",
        "tables": [
            "cards",
            "legalities",
            "maxbanned"
        ],
        "columns": [
            "maxbanned.format",
            "legalities.format",
            "legalities.status",
            "cards.name",
            "legalities.uuid",
            "cards.uuid"
        ],
        "values": [
            {
                "table": "legalities",
                "column": "status",
                "value": "Banned",
                "condition": "="
            },
            {
                "table": "legalities",
                "column": "status",
                "value": "Banned",
                "condition": "="
            },
            {
                "table": "",
                "column": "status",
                "value": "Banned",
                "condition": "="
            }
        ],
        "db_id": "card_games",
        "source": "bird_dev",
        "evidence": "play format refers to format; banned status refers to status = 'Banned'; the highest number of banned status refers to MAX(COUNT(status = 'Banned'))",
        "values_list": [
            "legalities.status.banned",
            "legalities.status.banned",
            ".status.banned"
        ],
        "original_question": "Which of the play format has the highest number of banned status? Indicate the play format and the names of all the card meet the condition.",
        "question": "Which of the play format has the highest number of Prohibited status? Indicate the play format and the names of all the card meet the condition.",
        "original_SQL": "WITH MaxBanned AS (SELECT format, COUNT(*) AS count_banned FROM legalities WHERE status = 'Banned' GROUP BY format ORDER BY COUNT(*) DESC LIMIT 1) SELECT T2.format, T1.name FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid INNER JOIN MaxBanned MB ON MB.format = T2.format WHERE T2.status = 'Banned'",
        "changes_information": {
            "original_value": "Banned",
            "synonym": "Prohibited"
        }
    },
    {
        "SQL": "SELECT T1.name, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE T1.edhrecRank = 1 AND T2.status = 'Banned' GROUP BY T1.name, T2.format",
        "tables": [
            "cards",
            "legalities"
        ],
        "columns": [
            "legalities.format",
            "legalities.status",
            "cards.name",
            "legalities.uuid",
            "cards.uuid",
            "cards.edhrecrank"
        ],
        "values": [
            {
                "table": "cards",
                "column": "edhrecrank",
                "value": "1",
                "condition": "="
            },
            {
                "table": "legalities",
                "column": "status",
                "value": "Banned",
                "condition": "="
            }
        ],
        "db_id": "card_games",
        "source": "bird_dev",
        "evidence": "ranked 1st on EDHRec refers to edhrecRank = 1; banned refers to status = 'Banned'; play format refers to format; cards name refers to name",
        "values_list": [
            "cards.edhrecrank.1",
            "legalities.status.banned"
        ],
        "original_question": "Which cards are ranked 1st on EDHRec? List all of the cards name and its banned play format.",
        "question": "Which cards are ranked 1st on EDHRec? List all of the cards name and its Prohibited play format.",
        "original_SQL": "SELECT T1.name, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE T1.edhrecRank = 1 AND T2.status = 'Banned' GROUP BY T1.name, T2.format",
        "changes_information": {
            "original_value": "Banned",
            "synonym": "Prohibited"
        }
    },
    {
        "SQL": "SELECT T2.expense_description FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.t_shirt_size = 'Large'",
        "tables": [
            "member",
            "expense"
        ],
        "columns": [
            "expense.link_to_member",
            "member.t_shirt_size",
            "expense.expense_description",
            "member.member_id"
        ],
        "values": [
            {
                "table": "member",
                "column": "t_shirt_size",
                "value": "Large",
                "condition": "="
            }
        ],
        "db_id": "student_club",
        "source": "bird_dev",
        "evidence": "kind of expenses refers to expense_description; t_shirt_size = 'X-Large'",
        "values_list": [
            "member.t_shirt_size.large"
        ],
        "original_question": "What kind of expenses incurred by members who have X-Large in size of tee shirt?",
        "question": "What kind of expenses incurred by members who have big in size of tee shirt?",
        "original_SQL": "SELECT T2.expense_description FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.t_shirt_size = 'X-Large'",
        "changes_information": {
            "original_value": "Large",
            "synonym": "big"
        }
    },
    {
        "SQL": "SELECT SEX FROM Patient WHERE Diagnosis = 'arthralgia' AND `First Date` IS NOT NULL ORDER BY `First Date` ASC LIMIT 1",
        "tables": [
            "patient"
        ],
        "columns": [
            "patient.first date",
            "patient.diagnosis",
            "patient.sex"
        ],
        "values": [
            {
                "table": "patient",
                "column": "diagnosis",
                "value": "arthralgia",
                "condition": "="
            }
        ],
        "db_id": "thrombosis_prediction",
        "source": "bird_dev",
        "evidence": "gender means SEX; 'AORTITIS' refers to Diagnosis;",
        "values_list": [
            "patient.diagnosis.arthralgia"
        ],
        "original_question": "What was the gender of the first AORTITIS diagnosed patient?",
        "question": "What was the gender of the first joint pain diagnosed patient?",
        "original_SQL": "SELECT SEX FROM Patient WHERE Diagnosis = 'AORTITIS' AND `First Date` IS NOT NULL ORDER BY `First Date` ASC LIMIT 1",
        "changes_information": {
            "original_value": "arthralgia",
            "synonym": "joint pain"
        }
    },
    {
        "SQL": "SELECT DISTINCT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'dog' OR T3.pettype  =  'dog'",
        "tables": [
            "has_pet",
            "pets",
            "student"
        ],
        "columns": [
            "pets.petid",
            "has_pet.petid",
            "student.fname",
            "has_pet.stuid",
            "pets.pettype",
            "student.stuid"
        ],
        "values": [
            {
                "table": "pets",
                "column": "pettype",
                "value": "dog",
                "condition": "="
            },
            {
                "table": "pets",
                "column": "pettype",
                "value": "dog",
                "condition": "="
            }
        ],
        "db_id": "pets_1",
        "source": "spider_dev",
        "evidence": "",
        "values_list": [
            "pets.pettype.dog",
            "pets.pettype.dog"
        ],
        "original_question": "Find the first name of students who have cat or dog pet.",
        "question": "Find the first name of students who have canine or dog pet.",
        "original_SQL": "SELECT DISTINCT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat' OR T3.pettype  =  'dog'",
        "changes_information": {
            "original_value": "dog",
            "synonym": "canine"
        }
    },
    {
        "SQL": "SELECT DISTINCT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'dog' OR T3.pettype  =  'dog'",
        "tables": [
            "has_pet",
            "pets",
            "student"
        ],
        "columns": [
            "pets.petid",
            "has_pet.petid",
            "student.fname",
            "has_pet.stuid",
            "pets.pettype",
            "student.stuid"
        ],
        "values": [
            {
                "table": "pets",
                "column": "pettype",
                "value": "dog",
                "condition": "="
            },
            {
                "table": "pets",
                "column": "pettype",
                "value": "dog",
                "condition": "="
            }
        ],
        "db_id": "pets_1",
        "source": "spider_dev",
        "evidence": "",
        "values_list": [
            "pets.pettype.dog",
            "pets.pettype.dog"
        ],
        "original_question": "What are the first names of every student who has a cat or dog as a pet?",
        "question": "What are the first names of every student who has a canine or dog as a pet?",
        "original_SQL": "SELECT DISTINCT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat' OR T3.pettype  =  'dog'",
        "changes_information": {
            "original_value": "dog",
            "synonym": "canine"
        }
    },
    {
        "SQL": "select t1.fname from student as t1 join has_pet as t2 on t1.stuid  =  t2.stuid join pets as t3 on t3.petid  =  t2.petid where t3.pettype  =  'dog' intersect select t1.fname from student as t1 join has_pet as t2 on t1.stuid  =  t2.stuid join pets as t3 on t3.petid  =  t2.petid where t3.pettype  =  'dog'",
        "tables": [
            "has_pet",
            "pets",
            "student"
        ],
        "columns": [
            "pets.petid",
            "has_pet.petid",
            "student.fname",
            "has_pet.stuid",
            "pets.pettype",
            "student.stuid"
        ],
        "values": [
            {
                "table": "pets",
                "column": "pettype",
                "value": "dog",
                "condition": "="
            },
            {
                "table": "pets",
                "column": "pettype",
                "value": "dog",
                "condition": "="
            }
        ],
        "db_id": "pets_1",
        "source": "spider_dev",
        "evidence": "",
        "values_list": [
            "pets.pettype.dog",
            "pets.pettype.dog"
        ],
        "original_question": "Find the first name of students who have both cat and dog pets .",
        "question": "Find the first name of students who have both canine and dog pets .",
        "original_SQL": "select t1.fname from student as t1 join has_pet as t2 on t1.stuid  =  t2.stuid join pets as t3 on t3.petid  =  t2.petid where t3.pettype  =  'cat' intersect select t1.fname from student as t1 join has_pet as t2 on t1.stuid  =  t2.stuid join pets as t3 on t3.petid  =  t2.petid where t3.pettype  =  'dog'",
        "changes_information": {
            "original_value": "dog",
            "synonym": "canine"
        }
    },
    {
        "SQL": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'dog' AND T1.stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')",
        "tables": [
            "has_pet",
            "pets",
            "student"
        ],
        "columns": [
            "pets.petid",
            "has_pet.petid",
            "student.fname",
            "has_pet.stuid",
            "pets.pettype",
            "student.age",
            "student.stuid"
        ],
        "values": [
            {
                "table": "pets",
                "column": "pettype",
                "value": "dog",
                "condition": "="
            },
            {
                "table": "pets",
                "column": "pettype",
                "value": "cat",
                "condition": "="
            }
        ],
        "db_id": "pets_1",
        "source": "spider_dev",
        "evidence": "",
        "values_list": [
            "pets.pettype.dog",
            "pets.pettype.cat"
        ],
        "original_question": "Find the first name and age of students who have a dog but do not have a cat as a pet.",
        "question": "Find the first name and age of students who have a canine but do not have a cat as a pet.",
        "original_SQL": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'dog' AND T1.stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')",
        "changes_information": {
            "original_value": "dog",
            "synonym": "canine"
        }
    },
    {
        "SQL": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'dog' AND T1.stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')",
        "tables": [
            "has_pet",
            "pets",
            "student"
        ],
        "columns": [
            "pets.petid",
            "has_pet.petid",
            "student.fname",
            "has_pet.stuid",
            "pets.pettype",
            "student.age",
            "student.stuid"
        ],
        "values": [
            {
                "table": "pets",
                "column": "pettype",
                "value": "dog",
                "condition": "="
            },
            {
                "table": "pets",
                "column": "pettype",
                "value": "cat",
                "condition": "="
            }
        ],
        "db_id": "pets_1",
        "source": "spider_dev",
        "evidence": "",
        "values_list": [
            "pets.pettype.dog",
            "pets.pettype.cat"
        ],
        "original_question": "What is the first name of every student who has a dog but does not have a cat?",
        "question": "What is the first name of every student who has a canine but does not have a cat?",
        "original_SQL": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'dog' AND T1.stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')",
        "changes_information": {
            "original_value": "dog",
            "synonym": "canine"
        }
    },
    {
        "SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Alien'",
        "tables": [
            "race",
            "superhero"
        ],
        "columns": [
            "superhero.superhero_name",
            "race.race",
            "superhero.race_id",
            "race.id"
        ],
        "values": [
            {
                "table": "race",
                "column": "race",
                "value": "Alien",
                "condition": "="
            }
        ],
        "db_id": "superhero",
        "source": "bird_dev",
        "evidence": "alien superheroes refers to race = 'Alien'; name of superhero refers to superhero_name;",
        "values_list": [
            "race.race.alien"
        ],
        "original_question": "Give the name of the alien superheroes.",
        "question": "Give the name of the Extraterrestrial superheroes.",
        "original_SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Alien'",
        "changes_information": {
            "original_value": "Alien",
            "synonym": "Extraterrestrial"
        }
    },
    {
        "SQL": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Alien'",
        "tables": [
            "race",
            "superhero"
        ],
        "columns": [
            "race.race",
            "superhero.full_name",
            "superhero.race_id",
            "race.id"
        ],
        "values": [
            {
                "table": "race",
                "column": "race",
                "value": "Alien",
                "condition": "="
            }
        ],
        "db_id": "superhero",
        "source": "bird_dev",
        "evidence": "Demi-God superheroes refers to race = 'Demi-God'",
        "values_list": [
            "race.race.alien"
        ],
        "original_question": "List down at least five full name of Demi-God superheroes.",
        "question": "List down at least five full name of Extraterrestrial superheroes.",
        "original_SQL": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Demi-God'",
        "changes_information": {
            "original_value": "Alien",
            "synonym": "Extraterrestrial"
        }
    },
    {
        "SQL": "SELECT DISTINCT T3.colour FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T1.height_cm = 185 AND T2.race = 'Alien'",
        "tables": [
            "race",
            "superhero",
            "colour"
        ],
        "columns": [
            "superhero.height_cm",
            "superhero.hair_colour_id",
            "race.id",
            "colour.colour",
            "superhero.race_id",
            "colour.id",
            "race.race"
        ],
        "values": [
            {
                "table": "superhero",
                "column": "height_cm",
                "value": "185",
                "condition": "="
            },
            {
                "table": "race",
                "column": "race",
                "value": "Alien",
                "condition": "="
            }
        ],
        "db_id": "superhero",
        "source": "bird_dev",
        "evidence": "185 cm tall refers to height_cm = 185; human superhero refers to race = 'human'; hair colour refers to colour where hair_colour_id = colour.id;",
        "values_list": [
            "superhero.height_cm.185",
            "race.race.alien"
        ],
        "original_question": "Provide the hair colour of the human superhero who is 185 cm tall.",
        "question": "Provide the hair colour of the Extraterrestrial superhero who is 185 cm tall.",
        "original_SQL": "SELECT DISTINCT T3.colour FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T1.height_cm = 185 AND T2.race = 'Human'",
        "changes_information": {
            "original_value": "Alien",
            "synonym": "Extraterrestrial"
        }
    },
    {
        "SQL": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Alien'",
        "tables": [
            "race",
            "superhero"
        ],
        "columns": [
            "race.race",
            "superhero.full_name",
            "superhero.race_id",
            "race.id"
        ],
        "values": [
            {
                "table": "race",
                "column": "race",
                "value": "Alien",
                "condition": "="
            }
        ],
        "db_id": "superhero",
        "source": "bird_dev",
        "evidence": "vampire heroes refers to race = 'Vampire';",
        "values_list": [
            "race.race.alien"
        ],
        "original_question": "Provide the full names of vampire heroes.",
        "question": "Provide the full names of Extraterrestrial heroes.",
        "original_SQL": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Vampire'",
        "changes_information": {
            "original_value": "Alien",
            "synonym": "Extraterrestrial"
        }
    },
    {
        "SQL": "SELECT T1.District FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.StatusType = 'Merged' ORDER BY T2.AvgScrRead DESC LIMIT 1",
        "tables": [
            "satscores",
            "schools"
        ],
        "columns": [
            "satscores.avgscrread",
            "schools.district",
            "schools.cdscode",
            "satscores.cds",
            "schools.statustype"
        ],
        "values": [
            {
                "table": "schools",
                "column": "statustype",
                "value": "Merged",
                "condition": "="
            }
        ],
        "db_id": "california_schools",
        "source": "bird_dev",
        "evidence": "",
        "values_list": [
            "schools.statustype.merged"
        ],
        "original_question": "Which active district has the highest average score in Reading?",
        "question": "Which Combined district has the highest average score in Reading?",
        "original_SQL": "SELECT T1.District FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.StatusType = 'Active' ORDER BY T2.AvgScrRead DESC LIMIT 1",
        "changes_information": {
            "original_value": "Merged",
            "synonym": "Combined"
        }
    },
    {
        "SQL": "SELECT DISTINCT County, School, ClosedDate FROM schools WHERE County = ( SELECT County FROM schools WHERE StatusType = 'Merged' GROUP BY County ORDER BY COUNT(School) DESC LIMIT 1 ) AND StatusType = 'Merged' AND school IS NOT NULL",
        "tables": [
            "schools"
        ],
        "columns": [
            "schools.closeddate",
            "schools.school",
            "schools.county",
            "schools.statustype"
        ],
        "values": [
            {
                "table": "schools",
                "column": "statustype",
                "value": "Merged",
                "condition": "="
            },
            {
                "table": "",
                "column": "statustype",
                "value": "Closed",
                "condition": "="
            },
            {
                "table": "",
                "column": "statustype",
                "value": "Closed",
                "condition": "="
            }
        ],
        "db_id": "california_schools",
        "source": "bird_dev",
        "evidence": "Closure date and closed date are synonyms; 'Closed' was mentioned in schools.StatusType.",
        "values_list": [
            "schools.statustype.merged",
            ".statustype.closed",
            ".statustype.closed"
        ],
        "original_question": "Which different county has the most number of closed schools? Please provide the name of each school as well as the closure date.",
        "question": "Which different county has the most number of Combined schools? Please provide the name of each school as well as the closure date.",
        "original_SQL": "SELECT DISTINCT County, School, ClosedDate FROM schools WHERE County = ( SELECT County FROM schools WHERE StatusType = 'Closed' GROUP BY County ORDER BY COUNT(School) DESC LIMIT 1 ) AND StatusType = 'Closed' AND school IS NOT NULL",
        "changes_information": {
            "original_value": "Merged",
            "synonym": "Combined"
        }
    },
    {
        "SQL": "SELECT id FROM sets WHERE type = 'starter' ORDER BY totalSetSize DESC LIMIT 1",
        "tables": [
            "sets"
        ],
        "columns": [
            "sets.id",
            "sets.type",
            "sets.totalsetsize"
        ],
        "values": [
            {
                "table": "sets",
                "column": "type",
                "value": "starter",
                "condition": "="
            }
        ],
        "db_id": "card_games",
        "source": "bird_dev",
        "evidence": "expansion type refers to type where type = 'commander'; totalSetSize: The total number of cards in the set, including promotional and related supplemental products but excluding Alchemy modifications; highest total number of cards refers to MAX(totalSetSize)",
        "values_list": [
            "sets.type.starter"
        ],
        "original_question": "Among the sets whose expansion type is Commander, which set has the highest total number of cards including promotional and related supplemental products but excluding Alchemy modifications? Indicate the id of the set.",
        "question": "Among the sets whose expansion type is beginner, which set has the highest total number of cards including promotional and related supplemental products but excluding Alchemy modifications? Indicate the id of the set.",
        "original_SQL": "SELECT id FROM sets WHERE type = 'commander' ORDER BY totalSetSize DESC LIMIT 1",
        "changes_information": {
            "original_value": "starter",
            "synonym": "beginner"
        }
    },
    {
        "SQL": "SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_power AS T2 INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Intelligence' AND T1.id = T2.hero_id)AND EXISTS (SELECT 1 FROM publisher AS T4 WHERE T4.publisher_name = 'Marvel Comics' AND T1.publisher_id = T4.id)",
        "tables": [
            "publisher",
            "superhero",
            "hero_power",
            "superpower"
        ],
        "columns": [
            "superhero.id",
            "hero_power.power_id",
            "superpower.id",
            "publisher.publisher_name",
            "publisher.id",
            "hero_power.hero_id",
            "superpower.power_name",
            "superhero.publisher_id"
        ],
        "values": [
            {
                "table": "superpower",
                "column": "power_name",
                "value": "Intelligence",
                "condition": "="
            },
            {
                "table": "publisher",
                "column": "publisher_name",
                "value": "Marvel Comics",
                "condition": "="
            }
        ],
        "db_id": "superhero",
        "source": "bird_dev",
        "evidence": "the superheroes from Marvel Comics refers to publisher_name = 'Marvel Comics'; super power of \"Super Strength\" refers to power_name = 'Super Strength';",
        "values_list": [
            "superpower.power_name.super strength",
            "publisher.publisher_name.marvel comics"
        ],
        "original_question": "List the superheroes from Marvel Comics who have the super power of 'Super Strength'.",
        "question": "List the superheroes from Marvel Comics who have the super power of 'smart'.",
        "original_SQL": "SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_power AS T2 INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Super Strength' AND T1.id = T2.hero_id)AND EXISTS (SELECT 1 FROM publisher AS T4 WHERE T4.publisher_name = 'Marvel Comics' AND T1.publisher_id = T4.id)",
        "changes_information": {
            "original_value": "Intelligence",
            "synonym": "smart"
        }
    },
    {
        "SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Intelligence'",
        "tables": [
            "superhero",
            "hero_power",
            "superpower"
        ],
        "columns": [
            "hero_power.power_id",
            "superhero.id",
            "superpower.id",
            "superhero.superhero_name",
            "hero_power.hero_id",
            "superpower.power_name"
        ],
        "values": [
            {
                "table": "superpower",
                "column": "power_name",
                "value": "Intelligence",
                "condition": "="
            }
        ],
        "db_id": "superhero",
        "source": "bird_dev",
        "evidence": "name of superheroes refers to refers to superhero_name; the power of death touch refers to power_name = 'Death Touch'",
        "values_list": [
            "superpower.power_name.death touch"
        ],
        "original_question": "What are the names of the superheroes with the power of death touch?",
        "question": "What are the names of the superheroes with the power of smart?",
        "original_SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Death Touch'",
        "changes_information": {
            "original_value": "Intelligence",
            "synonym": "smart"
        }
    },
    {
        "SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Intelligence'",
        "tables": [
            "superhero",
            "hero_power",
            "superpower"
        ],
        "columns": [
            "hero_power.power_id",
            "superhero.id",
            "superpower.id",
            "superhero.superhero_name",
            "hero_power.hero_id",
            "superpower.power_name"
        ],
        "values": [
            {
                "table": "superpower",
                "column": "power_name",
                "value": "Intelligence",
                "condition": "="
            }
        ],
        "db_id": "superhero",
        "source": "bird_dev",
        "evidence": "name of superheroes refers to superhero_name; flight power refers to power_name = 'Flight';",
        "values_list": [
            "superpower.power_name.intelligence"
        ],
        "original_question": "List the name of superheroes with flight power.",
        "question": "List the name of superheroes with smart power.",
        "original_SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Flight'",
        "changes_information": {
            "original_value": "Intelligence",
            "synonym": "smart"
        }
    },
    {
        "SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Intelligence'",
        "tables": [
            "superhero",
            "hero_power",
            "superpower"
        ],
        "columns": [
            "hero_power.power_id",
            "superhero.id",
            "superpower.id",
            "superhero.superhero_name",
            "hero_power.hero_id",
            "superpower.power_name"
        ],
        "values": [
            {
                "table": "superpower",
                "column": "power_name",
                "value": "Intelligence",
                "condition": "="
            }
        ],
        "db_id": "superhero",
        "source": "bird_dev",
        "evidence": "adaptation power refers to power_name = 'Adaptation';",
        "values_list": [
            "superpower.power_name.intelligence"
        ],
        "original_question": "Provide superheroes' names who have the adaptation power.",
        "question": "Provide superheroes' names who have the smart power.",
        "original_SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Adaptation'",
        "changes_information": {
            "original_value": "Intelligence",
            "synonym": "smart"
        }
    },
    {
        "SQL": "SELECT id FROM superpower WHERE power_name = 'Intelligence'",
        "tables": [
            "superpower"
        ],
        "columns": [
            "superpower.power_name",
            "superpower.id"
        ],
        "values": [
            {
                "table": "superpower",
                "column": "power_name",
                "value": "Intelligence",
                "condition": "="
            }
        ],
        "db_id": "superhero",
        "source": "bird_dev",
        "evidence": "power ID refers to superpower.id; cryokinesis refers to power_name = 'cryokinesis';",
        "values_list": [
            "superpower.power_name.intelligence"
        ],
        "original_question": "What is the power ID of cryokinesis?",
        "question": "What is the power ID of smart?",
        "original_SQL": "SELECT id FROM superpower WHERE power_name = 'Cryokinesis'",
        "changes_information": {
            "original_value": "Intelligence",
            "synonym": "smart"
        }
    },
    {
        "SQL": "SELECT T4.gender FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T3.power_name = 'Intelligence'",
        "tables": [
            "superhero",
            "gender",
            "hero_power",
            "superpower"
        ],
        "columns": [
            "gender.gender",
            "hero_power.power_id",
            "superhero.id",
            "superpower.id",
            "gender.id",
            "superhero.gender_id",
            "hero_power.hero_id",
            "superpower.power_name"
        ],
        "values": [
            {
                "table": "superpower",
                "column": "power_name",
                "value": "Intelligence",
                "condition": "="
            }
        ],
        "db_id": "superhero",
        "source": "bird_dev",
        "evidence": "ability of Phoenix Force refers to power_name = 'Phoenix Force';",
        "values_list": [
            "superpower.power_name.phoenix force"
        ],
        "original_question": "Identify the gender of the superhero who has the ability of Phoenix Force.",
        "question": "Identify the gender of the superhero who has the ability of smart.",
        "original_SQL": "SELECT T4.gender FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T3.power_name = 'Phoenix Force'",
        "changes_information": {
            "original_value": "Intelligence",
            "synonym": "smart"
        }
    },
    {
        "SQL": "SELECT ExcerptPostId, WikiPostId FROM tags WHERE TagName = 'teaching'",
        "tables": [
            "tags"
        ],
        "columns": [
            "tags.tagname",
            "tags.wikipostid",
            "tags.excerptpostid"
        ],
        "values": [
            {
                "table": "tags",
                "column": "tagname",
                "value": "teaching",
                "condition": "="
            }
        ],
        "db_id": "codebase_community",
        "source": "bird_dev",
        "evidence": "tag named sample refers to TagName = 'sample';",
        "values_list": [
            "tags.tagname.teaching"
        ],
        "original_question": "What is the excerpt post ID and wiki post ID of the tag named sample?",
        "question": "What is the excerpt post ID and wiki post ID of the tag named educating?",
        "original_SQL": "SELECT ExcerptPostId, WikiPostId FROM tags WHERE TagName = 'sample'",
        "changes_information": {
            "original_value": "teaching",
            "synonym": "educating"
        }
    },
    {
        "SQL": "SELECT t3.team_long_name FROM Team AS t3 INNER JOIN Team_Attributes AS t4 ON t3.team_api_id = t4.team_api_id WHERE t4.buildUpPlayDribblingClass = 'Normal' AND t4.chanceCreationPassing < ( SELECT CAST(SUM(t2.chanceCreationPassing) AS REAL) / COUNT(t1.id) FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlayDribblingClass = 'Normal' AND SUBSTR(t2.`date`, 1, 4) = '2014') ORDER BY t4.chanceCreationPassing DESC",
        "tables": [
            "team_attributes",
            "team"
        ],
        "columns": [
            "team.team_api_id",
            "team_attributes.date",
            "team_attributes.team_api_id",
            "team_attributes.chancecreationpassing",
            "team_attributes.buildupplaydribblingclass",
            "team.id",
            "team.team_long_name"
        ],
        "values": [
            {
                "table": "team_attributes",
                "column": "buildupplaydribblingclass",
                "value": "Normal",
                "condition": "="
            },
            {
                "table": "team_attributes",
                "column": "buildupplaydribblingclass",
                "value": "Normal",
                "condition": "="
            },
            {
                "table": "team_attributes",
                "column": "buildupplaydribblingclass",
                "value": "Normal",
                "condition": "="
            }
        ],
        "db_id": "european_football_2",
        "source": "bird_dev",
        "evidence": "normal build-up play dribbling class refers to buildUpPlayDribblingClass = 'Normal'; in 2014 refers to date > = '2014-01-01 00:00:00' AND date < = '2014-01-31 00:00:00'; names of the teams refers to team_long_name; less than average chance creation passing = DIVIDE(SUM(chanceCreationPassing), COUNT(id)) > chanceCreationPassing;",
        "values_list": [
            "team_attributes.buildupplaydribblingclass.normal",
            "team_attributes.buildupplaydribblingclass.normal",
            "team_attributes.buildupplaydribblingclass.normal"
        ],
        "original_question": "For the teams with normal build-up play dribbling class in 2014, List the names of the teams with less than average chance creation passing, in descending order of chance creation passing.",
        "question": "For the teams with Average build-up play dribbling class in 2014, List the names of the teams with less than average chance creation passing, in descending order of chance creation passing.",
        "original_SQL": "SELECT t3.team_long_name FROM Team AS t3 INNER JOIN Team_Attributes AS t4 ON t3.team_api_id = t4.team_api_id WHERE t4.buildUpPlayDribblingClass = 'Normal' AND t4.chanceCreationPassing < ( SELECT CAST(SUM(t2.chanceCreationPassing) AS REAL) / COUNT(t1.id) FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlayDribblingClass = 'Normal' AND SUBSTR(t2.`date`, 1, 4) = '2014') ORDER BY t4.chanceCreationPassing DESC",
        "changes_information": {
            "original_value": "Normal",
            "synonym": "Average"
        }
    }
]